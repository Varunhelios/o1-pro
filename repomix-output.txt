This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: components/ui
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursor/rules/auth.mdc
.cursor/rules/backend.mdc
.cursor/rules/env.mdc
.cursor/rules/frontend.mdc
.cursor/rules/general.mdc
.cursor/rules/payments.mdc
.cursor/rules/storage.mdc
.cursor/rules/types.mdc
.cursorrules
.env.example
.eslintrc.json
.gitignore
.husky/pre-commit
.repo_ignore
actions/ai-actions.ts
actions/db/chats-actions.ts
actions/db/exercises-actions.ts
actions/db/lessons-actions.ts
actions/db/profiles-actions.ts
actions/db/progress-actions.ts
actions/storage/offline-actions.ts
actions/stripe-actions.ts
app/(auth)/layout.tsx
app/(auth)/login/[[...login]]/page.tsx
app/(auth)/signup/[[...signup]]/page.tsx
app/(marketing)/about/page.tsx
app/(marketing)/contact/_components/contact-form.tsx
app/(marketing)/contact/page.tsx
app/(marketing)/features/page.tsx
app/(marketing)/layout.tsx
app/(marketing)/page.tsx
app/(marketing)/pricing/page.tsx
app/api/stripe/webhooks/route.ts
app/community/chat/page.tsx
app/community/tutors/page.tsx
app/components/learn/lesson-card.tsx
app/components/learn/LessonCardWrapper.tsx
app/components/learn/pronunciation-guide.tsx
app/dashboard/page.tsx
app/db/schema/lessons-schema.ts
app/globals.css
app/layout.tsx
app/learn/[level]/page.tsx
app/learn/layout.tsx
app/practice/[type]/page.tsx
components.json
components/dashboard/progress-chart.tsx
components/landing/footer.tsx
components/landing/header.tsx
components/landing/hero.tsx
components/learn/lesson-card.tsx
components/learn/pronunciation-guide.tsx
components/magicui/animated-gradient-text.tsx
components/magicui/hero-video-dialog.tsx
components/practice/chatbot.tsx
components/practice/quiz-exercise.tsx
components/practice/speaking-exercise.tsx
components/practice/writing-exercise.tsx
components/utilities/providers.tsx
components/utilities/tailwind-indicator.tsx
components/utilities/theme-switcher.tsx
db/db.ts
db/migrations/0000_freezing_peter_quill.sql
db/migrations/meta/_journal.json
db/migrations/meta/0000_snapshot.json
db/schema/chat-messages-schema.ts
db/schema/exercises-schema.ts
db/schema/index.ts
db/schema/lessons-schema.ts
db/schema/profiles-schema.ts
db/schema/progress-schema.ts
drizzle.config.ts
lib/ai/openai.ts
lib/hooks/use-copy-to-clipboard.tsx
lib/hooks/use-mobile.tsx
lib/hooks/use-toast.ts
lib/stripe.ts
lib/utils.ts
license
middleware.ts
next.config.mjs
package.json
path/to/lesson-card
path/to/sendMessageAction
postcss.config.mjs
prettier.config.cjs
README.md
tailwind.config.ts
tsconfig.json
types/index.ts
types/server-action-types.ts
types/web-speech-types.ts

================================================================
Files
================================================================

================
File: .cursor/rules/auth.mdc
================
---
description: Follow these rules when working on auth.
globs: 
---
# Auth Rules

Follow these rules when working on auth.

It uses Clerk for authentication.

## General Rules

- Import the auth helper with `import { auth } from "@clerk/nextjs/server"` in server components
- await the auth helper in server action

================
File: .cursor/rules/backend.mdc
================
---
description: Follow these rules when working on the backend.
globs: 
---
# Backend Rules

Follow these rules when working on the backend.

It uses Postgres, Supabase, Drizzle ORM, and Server Actions.

## General Rules

- Never generate migrations. You do not have to do anything in the `db/migrations` folder inluding migrations and metadata. Ignore it.

## Organization

## Schemas

- When importing schemas, use `@/db/schema`
- Name files like `example-schema.ts`
- All schemas should go in `db/schema`
- Make sure to export the schema in `db/schema/index.ts`
- Make sure to add the schema to the `schema` object in `db/db.ts`
- If using a userId, always use `userId: text("user_id").notNull()`
- Always include createdAt and updatedAt columns in all tables
- Make sure to cascade delete when necessary
- Use enums for columns that have a limited set of possible values such as:

```ts
import { pgEnum } from "drizzle-orm/pg-core"

export const membershipEnum = pgEnum("membership", ["free", "pro"])

membership: membershipEnum("membership").notNull().default("free")
```

Example of a schema:

`db/schema/todos-schema.ts`

```ts
import { boolean, pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core"

export const todosTable = pgTable("todos", {
  id: uuid("id").defaultRandom().primaryKey(),
  userId: text("user_id").notNull(),
  content: text("content").notNull(),
  completed: boolean("completed").default(false).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .notNull()
    .$onUpdate(() => new Date())
})

export type InsertTodo = typeof todosTable.$inferInsert
export type SelectTodo = typeof todosTable.$inferSelect
```

And exporting it:

`db/schema/index.ts`

```ts
export * from "./todos-schema"
```

And adding it to the schema in `db/db.ts`:

`db/db.ts`

```ts
import { todosTable } from "@/db/schema"

const schema = {
  todos: todosTable
}
```

And a more complex schema:

```ts
import { pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core"

export const chatsTable = pgTable("chats", {
  id: uuid("id").defaultRandom().primaryKey(),
  userId: text("user_id").notNull(),
  name: text("name").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .notNull()
    .$onUpdate(() => new Date())
})

export type InsertChat = typeof chatsTable.$inferInsert
export type SelectChat = typeof chatsTable.$inferSelect
```

```ts
import { pgEnum, pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core"
import { chatsTable } from "./chats-schema"

export const roleEnum = pgEnum("role", ["assistant", "user"])

export const messagesTable = pgTable("messages", {
  id: uuid("id").defaultRandom().primaryKey(),
  chatId: uuid("chat_id")
    .references(() => chatsTable.id, { onDelete: "cascade" })
    .notNull(),
  content: text("content").notNull(),
  role: roleEnum("role").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .notNull()
    .$onUpdate(() => new Date())
})

export type InsertMessage = typeof messagesTable.$inferInsert
export type SelectMessage = typeof messagesTable.$inferSelect
```

And exporting it:

`db/schema/index.ts`

```ts
export * from "./chats-schema"
export * from "./messages-schema"
```

And adding it to the schema in `db/db.ts`:

`db/db.ts`

```ts
import { chatsTable, messagesTable } from "@/db/schema"

const schema = {
  chats: chatsTable,
  messages: messagesTable
}
```

## Server Actions

- When importing actions, use `@/actions` or `@/actions/db` if db related
- DB related actions should go in the `actions/db` folder
- Other actions should go in the `actions` folder
- Name files like `example-actions.ts`
- All actions should go in the `actions` folder
- Only write the needed actions
- Return an ActionState with the needed data type from actions
- Include Action at the end of function names `Ex: exampleFunction -> exampleFunctionAction`
- Actions should return a Promise<ActionState<T>>
- Sort in CRUD order: Create, Read, Update, Delete
- Make sure to return undefined as the data type if the action is not supposed to return any data
- **Date Handling:** For columns defined as `PgDateString` (or any date string type), always convert JavaScript `Date` objects to ISO strings using `.toISOString()` before performing operations (e.g., comparisons or insertions). This ensures value type consistency and prevents type errors.

```ts
export type ActionState<T> =
  | { isSuccess: true; message: string; data: T }
  | { isSuccess: false; message: string; data?: never }
```

Example of an action:

`actions/db/todos-actions.ts`

```ts
"use server"

import { db } from "@/db/db"
import { InsertTodo, SelectTodo, todosTable } from "@/db/schema/todos-schema"
import { ActionState } from "@/types"
import { eq } from "drizzle-orm"

export async function createTodoAction(
  todo: InsertTodo
): Promise<ActionState<SelectTodo>> {
  try {
    const [newTodo] = await db.insert(todosTable).values(todo).returning()
    return {
      isSuccess: true,
      message: "Todo created successfully",
      data: newTodo
    }
  } catch (error) {
    console.error("Error creating todo:", error)
    return { isSuccess: false, message: "Failed to create todo" }
  }
}

export async function getTodosAction(
  userId: string
): Promise<ActionState<SelectTodo[]>> {
  try {
    const todos = await db.query.todos.findMany({
      where: eq(todosTable.userId, userId)
    })
    return {
      isSuccess: true,
      message: "Todos retrieved successfully",
      data: todos
    }
  } catch (error) {
    console.error("Error getting todos:", error)
    return { isSuccess: false, message: "Failed to get todos" }
  }
}

export async function updateTodoAction(
  id: string,
  data: Partial<InsertTodo>
): Promise<ActionState<SelectTodo>> {
  try {
    const [updatedTodo] = await db
      .update(todosTable)
      .set(data)
      .where(eq(todosTable.id, id))
      .returning()

    return {
      isSuccess: true,
      message: "Todo updated successfully",
      data: updatedTodo
    }
  } catch (error) {
    console.error("Error updating todo:", error)
    return { isSuccess: false, message: "Failed to update todo" }
  }
}

export async function deleteTodoAction(id: string): Promise<ActionState<void>> {
  try {
    await db.delete(todosTable).where(eq(todosTable.id, id))
    return {
      isSuccess: true,
      message: "Todo deleted successfully",
      data: undefined
    }
  } catch (error) {
    console.error("Error deleting todo:", error)
    return { isSuccess: false, message: "Failed to delete todo" }
  }
}
```

================
File: .cursor/rules/env.mdc
================
---
description: Follow these rules when working with environment variables.
globs: 
---
# Env Rules

- If you update environment variables, update the `.env.example` file
- All environment variables should go in `.env.local`
- Do not expose environment variables to the frontend
- Use `NEXT_PUBLIC_` prefix for environment variables that need to be accessed from the frontend
- You may import environment variables in server actions and components by using `process.env.VARIABLE_NAME`

================
File: .cursor/rules/frontend.mdc
================
---
description: Follow these rules when working on the frontend.
globs: 
---
# Frontend Rules

Follow these rules when working on the frontend.

It uses Next.js, Tailwind, Shadcn, and Framer Motion.

## General Rules

- Use `lucide-react` for icons
- useSidebar must be used within a SidebarProvider

## Components

- Use divs instead of other html tags unless otherwise specified
- Separate the main parts of a component's html with an extra blank line for visual spacing
- Always tag a component with either `use server` or `use client` at the top, including layouts and pages

### Organization

- All components be named using kebab case like `example-component.tsx` unless otherwise specified
- Put components in `/_components` in the route if one-off components
- Put components in `/components` from the root if shared components

### Data Fetching

- Fetch data in server components and pass the data down as props to client components.
- Use server actions from `/actions` to mutate data.

### Server Components

- Use `"use server"` at the top of the file.
- Implement Suspense for asynchronous data fetching to show loading states while data is being fetched.
- If no asynchronous logic is required for a given server component, you do not need to wrap the component in `<Suspense>`. You can simply return the final UI directly since there is no async boundary needed.
- If asynchronous fetching is required, you can use a `<Suspense>` boundary and a fallback to indicate a loading state while data is loading.
- Server components cannot be imported into client components. If you want to use a server component in a client component, you must pass the as props using the "children" prop
- params in server pages should be awaited such as `const { courseId } = await params` where the type is `params: Promise<{ courseId: string }>`

Example of a server layout:

```tsx
"use server"

export default async function ExampleServerLayout({
  children
}: {
  children: React.ReactNode
}) {
  return children
}
```

Example of a server page (with async logic):

```tsx
"use server"

import { Suspense } from "react"
import { SomeAction } from "@/actions/some-actions"
import SomeComponent from "./_components/some-component"
import SomeSkeleton from "./_components/some-skeleton"

export default async function ExampleServerPage() {
  return (
    <Suspense fallback={<SomeSkeleton className="some-class" />}>
      <SomeComponentFetcher />
    </Suspense>
  )
}

async function SomeComponentFetcher() {
  const { data } = await SomeAction()
  return <SomeComponent className="some-class" initialData={data || []} />
}
```

Example of a server page (no async logic required):

```tsx
"use server"

import SomeClientComponent from "./_components/some-client-component"

// In this case, no asynchronous work is being done, so no Suspense or fallback is required.
export default async function ExampleServerPage() {
  return <SomeClientComponent initialData={[]} />
}
```

Example of a server component:

```tsx
"use server"

interface ExampleServerComponentProps {
  // Your props here
}

export async function ExampleServerComponent({
  props
}: ExampleServerComponentProps) {
  // Your code here
}
```

### Client Components

- Use `"use client"` at the top of the file
- Client components can safely rely on props passed down from server components, or handle UI interactions without needing <Suspense> if there’s no async logic.
- Never use server actions in client components. If you need to create a new server action, create it in `/actions`

Example of a client page:

```tsx
"use client"

export default function ExampleClientPage() {
  // Your code here
}
```

Example of a client component:

```tsx
"use client"

interface ExampleClientComponentProps {
  initialData: any[]
}

export default function ExampleClientComponent({
  initialData
}: ExampleClientComponentProps) {
  // Client-side logic here
  return <div>{initialData.length} items</div>
}
```

================
File: .cursor/rules/general.mdc
================
---
description: Follow these rules for all requests.
globs: 
---
# Project Instructions

Use specification and guidelines as you build the app.

Write the complete code for every step. Do not get lazy.

Your goal is to completely finish whatever I ask for.

You will see  tags in the code. These are context tags that you should use to help you understand the codebase.

## Overview

This is a web app template.

## Tech Stack

- Frontend: Next.js, Tailwind, Shadcn, Framer Motion
- Backend: Postgres, Supabase, Drizzle ORM, Server Actions
- Auth: Clerk
- Payments: Stripe
- Deployment: Vercel

## Project Structure

- `actions` - Server actions
  - `db` - Database related actions
  - Other actions
- `app` - Next.js app router
  - `api` - API routes
  - `route` - An example route
    - `_components` - One-off components for the route
    - `layout.tsx` - Layout for the route
    - `page.tsx` - Page for the route
- `components` - Shared components
  - `ui` - UI components
  - `utilities` - Utility components
- `db` - Database
  - `schema` - Database schemas
- `lib` - Library code
  - `hooks` - Custom hooks
- `prompts` - Prompt files
- `public` - Static assets
- `types` - Type definitions

## Rules

Follow these rules when building the app.

### General Rules

- All files should have a comment at the very top of the file that consisely explain what it does
- Use `@` to import anything from the app unless otherwise specified
- Use kebab case for all files and folders unless otherwise specified
- Don't update shadcn components unless otherwise specified

================
File: .cursor/rules/payments.mdc
================
---
description: Follow these rules when working on payments.
globs: 
---
# Payments Rules

Follow these rules when working on payments.

It uses Stripe for payments.

================
File: .cursor/rules/storage.mdc
================
---
description: Follow these rules when working on file storage.
globs: 
---
# Storage Rules

Follow these rules when working with Supabase Storage.

It uses Supabase Storage for file uploads, downloads, and management.

## General Rules

- Always use environment variables for bucket names to maintain consistency across environments
- Never hardcode bucket names in the application code
- Always handle file size limits and allowed file types at the application level
- Use the `upsert` method instead of `upload` when you want to replace existing files
- Always implement proper error handling for storage operations
- Use content-type headers when uploading files to ensure proper file handling

## Organization

### Buckets

- Name buckets in kebab-case: `user-uploads`, `profile-images`
- Create separate buckets for different types of files (e.g., `profile-images`, `documents`, `attachments`)
- Document bucket purposes in a central location
- Set appropriate bucket policies (public/private) based on access requirements
- Implement RLS (Row Level Security) policies for buckets that need user-specific access
- Make sure to let me know instructions for setting up RLS policies on Supabase since you can't do this yourself, including the SQL scripts I need to run in the editor

### File Structure

- Organize files in folders based on their purpose and ownership
- Use predictable, collision-resistant naming patterns
- Structure: `{bucket}/{userId}/{purpose}/{filename}`
- Example: `profile-images/123e4567-e89b/avatar/profile.jpg`
- Include timestamps in filenames when version history is important
- Example: `documents/123e4567-e89b/contracts/2024-02-13-contract.pdf`

## Actions

- When importing storage actions, use `@/actions/storage`
- Name files like `example-storage-actions.ts`
- Include Storage at the end of function names `Ex: uploadFile -> uploadFileStorage`
- Follow the same ActionState pattern as DB actions

Example of a storage action:

```ts
"use server"

import { createClientComponentClient } from "@supabase/auth-helpers-nextjs"
import { ActionState } from "@/types"

export async function uploadFileStorage(
  bucket: string,
  path: string,
  file: File
): Promise<ActionState<{ path: string }>> {
  try {
    const supabase = createClientComponentClient()
    
    const { data, error } = await supabase
      .storage
      .from(bucket)
      .upload(path, file, {
        upsert: false,
        contentType: file.type
      })

    if (error) throw error

    return {
      isSuccess: true,
      message: "File uploaded successfully",
      data: { path: data.path }
    }
  } catch (error) {
    console.error("Error uploading file:", error)
    return { isSuccess: false, message: "Failed to upload file" }
  }
}
```

## File Handling

### Upload Rules

- Always validate file size before upload
- Implement file type validation using both extension and MIME type
- Generate unique filenames to prevent collisions
- Set appropriate content-type headers
- Handle existing files appropriately (error or upsert)

Example validation:

```ts
const MAX_FILE_SIZE = 10 * 1024 * 1024 // 10MB
const ALLOWED_TYPES = ["image/jpeg", "image/png", "image/webp"]

function validateFile(file: File): boolean {
  if (file.size > MAX_FILE_SIZE) {
    throw new Error("File size exceeds limit")
  }
  
  if (!ALLOWED_TYPES.includes(file.type)) {
    throw new Error("File type not allowed")
  }
  
  return true
}
```

### Download Rules

- Always handle missing files gracefully
- Implement proper error handling for failed downloads
- Use signed URLs for private files

### Delete Rules

- Implement soft deletes when appropriate
- Clean up related database records when deleting files
- Handle bulk deletions carefully
- Verify ownership before deletion
- Always delete all versions/transforms of a file

## Security

### Bucket Policies

- Make buckets private by default
- Only make buckets public when absolutely necessary
- Use RLS policies to restrict access to authorized users
- Example RLS policy:

```sql
CREATE POLICY "Users can only access their own files"
ON storage.objects
FOR ALL
USING (auth.uid()::text = (storage.foldername(name))[1]);
```

### Access Control

- Generate short-lived signed URLs for private files
- Implement proper CORS policies
- Use separate buckets for public and private files
- Never expose internal file paths
- Validate user permissions before any operation

## Error Handling

- Implement specific error types for common storage issues
- Always provide meaningful error messages
- Implement retry logic for transient failures
- Log storage errors separately for monitoring

## Optimization

- Implement progressive upload for large files
- Clean up temporary files and failed uploads
- Use batch operations when handling multiple files

================
File: .cursor/rules/types.mdc
================
---
description: Follow these rules when working with types.
globs: 
---
# Type Rules

- When importing types, use `@/types`
- Name files like `example-types.ts`
- All types should go in `types`
- Make sure to export the types in `types/index.ts`
- Prefer interfaces over type aliases
- If referring to db types, use `@/db/schema` such as `SelectTodo` from `todos-schema.ts`

An example of a type:

`types/actions-types.ts`

```ts
export type ActionState<T> =
  | { isSuccess: true; message: string; data: T }
  | { isSuccess: false; message: string; data?: never }
```

And exporting it:

`types/index.ts`

```ts
export * from "./actions-types"
```

================
File: .cursorrules
================
# Project Instructions

Use specification and guidelines as you build the app.

Write the complete code for every step. Do not get lazy.

Your goal is to completely finish whatever I ask for.

You will see tags in the code. These are context tags that you should use to help you understand the codebase.

## Overview

This is a web app template.

## Tech Stack

- Frontend: Next.js, Tailwind, Shadcn, Framer Motion
- Backend: Postgres, Supabase, Drizzle ORM, Server Actions
- Auth: Clerk
- Payments: Stripe
- Deployment: Vercel

## Project Structure

- `actions` - Server actions
  - `db` - Database related actions
  - Other actions
- `app` - Next.js app router
  - `api` - API routes
  - `route` - An example route
    - `_components` - One-off components for the route
    - `layout.tsx` - Layout for the route
    - `page.tsx` - Page for the route
- `components` - Shared components
  - `ui` - UI components
  - `utilities` - Utility components
- `db` - Database
  - `schema` - Database schemas
- `lib` - Library code
  - `hooks` - Custom hooks
- `prompts` - Prompt files
- `public` - Static assets
- `types` - Type definitions

## Rules

Follow these rules when building the app.

### General Rules

- Use `@` to import anything from the app unless otherwise specified
- Use kebab case for all files and folders unless otherwise specified
- Don't update shadcn components unless otherwise specified

#### Env Rules

- If you update environment variables, update the `.env.example` file
- All environment variables should go in `.env.local`
- Do not expose environment variables to the frontend
- Use `NEXT_PUBLIC_` prefix for environment variables that need to be accessed from the frontend
- You may import environment variables in server actions and components by using `process.env.VARIABLE_NAME`

#### Type Rules

Follow these rules when working with types.

- When importing types, use `@/types`
- Name files like `example-types.ts`
- All types should go in `types`
- Make sure to export the types in `types/index.ts`
- Prefer interfaces over type aliases
- If referring to db types, use `@/db/schema` such as `SelectTodo` from `todos-schema.ts`

An example of a type:

`types/actions-types.ts`

```ts
export type ActionState<T> =
  | { isSuccess: true; message: string; data: T }
  | { isSuccess: false; message: string; data?: never }
```

And exporting it:

`types/index.ts`

```ts
export * from "./actions-types"
```

### Frontend Rules

Follow these rules when working on the frontend.

It uses Next.js, Tailwind, Shadcn, and Framer Motion.

#### General Rules

- Use `lucide-react` for icons
- useSidebar must be used within a SidebarProvider

#### Components

- Use divs instead of other html tags unless otherwise specified
- Separate the main parts of a component's html with an extra blank line for visual spacing
- Always tag a component with either `use server` or `use client` at the top, including layouts and pages

##### Organization

- All components be named using kebab case like `example-component.tsx` unless otherwise specified
- Put components in `/_components` in the route if one-off components
- Put components in `/components` from the root if shared components

##### Data Fetching

- Fetch data in server components and pass the data down as props to client components.
- Use server actions from `/actions` to mutate data.

##### Server Components

- Use `"use server"` at the top of the file.
- Implement Suspense for asynchronous data fetching to show loading states while data is being fetched.
- If no asynchronous logic is required for a given server component, you do not need to wrap the component in `<Suspense>`. You can simply return the final UI directly since there is no async boundary needed.
- If asynchronous fetching is required, you can use a `<Suspense>` boundary and a fallback to indicate a loading state while data is loading.
- Server components cannot be imported into client components. If you want to use a server component in a client component, you must pass the as props using the "children" prop
- params in server pages should be awaited such as `const { courseId } = await params` where the type is `params: Promise<{ courseId: string }>`

Example of a server layout:

```tsx
"use server"

export default async function ExampleServerLayout({
  children
}: {
  children: React.ReactNode
}) {
  return children
}
```

Example of a server page (with async logic):

```tsx
"use server"

import { Suspense } from "react"
import { SomeAction } from "@/actions/some-actions"
import SomeComponent from "./_components/some-component"
import SomeSkeleton from "./_components/some-skeleton"

export default async function ExampleServerPage() {
  return (
    <Suspense fallback={<SomeSkeleton className="some-class" />}>
      <SomeComponentFetcher />
    </Suspense>
  )
}

async function SomeComponentFetcher() {
  const { data } = await SomeAction()
  return <SomeComponent className="some-class" initialData={data || []} />
}
```

Example of a server page (no async logic required):

```tsx
"use server"

import SomeClientComponent from "./_components/some-client-component"

// In this case, no asynchronous work is being done, so no Suspense or fallback is required.
export default async function ExampleServerPage() {
  return <SomeClientComponent initialData={[]} />
}
```

Example of a server component:

```tsx
"use server"

interface ExampleServerComponentProps {
  // Your props here
}

export async function ExampleServerComponent({
  props
}: ExampleServerComponentProps) {
  // Your code here
}
```

##### Client Components

- Use `"use client"` at the top of the file
- Client components can safely rely on props passed down from server components, or handle UI interactions without needing <Suspense> if there’s no async logic.
- Never use server actions in client components. If you need to create a new server action, create it in `/actions`

Example of a client page:

```tsx
"use client"

export default function ExampleClientPage() {
  // Your code here
}
```

Example of a client component:

```tsx
"use client"

interface ExampleClientComponentProps {
  initialData: any[]
}

export default function ExampleClientComponent({
  initialData
}: ExampleClientComponentProps) {
  // Client-side logic here
  return <div>{initialData.length} items</div>
}
```

### Backend Rules

Follow these rules when working on the backend.

It uses Postgres, Supabase, Drizzle ORM, and Server Actions.

#### General Rules

- Never generate migrations. You do not have to do anything in the `db/migrations` folder inluding migrations and metadata. Ignore it.

#### Organization

#### Schemas

- When importing schemas, use `@/db/schema`
- Name files like `example-schema.ts`
- All schemas should go in `db/schema`
- Make sure to export the schema in `db/schema/index.ts`
- Make sure to add the schema to the `schema` object in `db/db.ts`
- If using a userId, always use `userId: text("user_id").notNull()`
- Always include createdAt and updatedAt columns in all tables
- Make sure to cascade delete when necessary
- Use enums for columns that have a limited set of possible values such as:

```ts
import { pgEnum } from "drizzle-orm/pg-core"

export const membershipEnum = pgEnum("membership", ["free", "pro"])

membership: membershipEnum("membership").notNull().default("free")
```

Example of a schema:

`db/schema/todos-schema.ts`

```ts
import { boolean, pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core"

export const todosTable = pgTable("todos", {
  id: uuid("id").defaultRandom().primaryKey(),
  userId: text("user_id").notNull(),
  content: text("content").notNull(),
  completed: boolean("completed").default(false).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .notNull()
    .$onUpdate(() => new Date())
})

export type InsertTodo = typeof todosTable.$inferInsert
export type SelectTodo = typeof todosTable.$inferSelect
```

And exporting it:

`db/schema/index.ts`

```ts
export * from "./todos-schema"
```

And adding it to the schema in `db/db.ts`:

`db/db.ts`

```ts
import { todosTable } from "@/db/schema"

const schema = { todos: todosTable }
```

And a more complex schema:

```ts
import { pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core"

export const chatsTable = pgTable("chats", {
  id: uuid("id").defaultRandom().primaryKey(),
  userId: text("user_id").notNull(),
  name: text("name").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .notNull()
    .$onUpdate(() => new Date())
})

export type InsertChat = typeof chatsTable.$inferInsert
export type SelectChat = typeof chatsTable.$inferSelect
```

```ts
import { pgEnum, pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core"
import { chatsTable } from "./chats-schema"

export const roleEnum = pgEnum("role", ["assistant", "user"])

export const messagesTable = pgTable("messages", {
  id: uuid("id").defaultRandom().primaryKey(),
  chatId: uuid("chat_id")
    .references(() => chatsTable.id, { onDelete: "cascade" })
    .notNull(),
  content: text("content").notNull(),
  role: roleEnum("role").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .notNull()
    .$onUpdate(() => new Date())
})

export type InsertMessage = typeof messagesTable.$inferInsert
export type SelectMessage = typeof messagesTable.$inferSelect
```

And exporting it:

`db/schema/index.ts`

```ts
export * from "./chats-schema"
export * from "./messages-schema"
```

And adding it to the schema in `db/db.ts`:

`db/db.ts`

```ts
import { chatsTable, messagesTable } from "@/db/schema"

const schema = { chats: chatsTable, messages: messagesTable }
```

#### Server Actions

- When importing actions, use `@/actions` or `@/actions/db` if db related
- DB related actions should go in the `actions/db` folder
- Other actions should go in the `actions` folder
- Name files like `example-actions.ts`
- All actions should go in the `actions` folder
- Only write the needed actions
- Return an ActionState with the needed data type from actions
- Include Action at the end of function names `Ex: exampleFunction -> exampleFunctionAction`
- Actions should return a Promise<ActionState<T>>
- Sort in CRUD order: Create, Read, Update, Delete
- Make sure to return undefined as the data type if the action is not supposed to return any data
- **Date Handling:** For columns defined as `PgDateString` (or any date string type), always convert JavaScript `Date` objects to ISO strings using `.toISOString()` before performing operations (e.g., comparisons or insertions). This ensures value type consistency and prevents type errors.

```ts
export type ActionState<T> =
  | { isSuccess: true; message: string; data: T }
  | { isSuccess: false; message: string; data?: never }
```

Example of an action:

`actions/db/todos-actions.ts`

```ts
"use server"

import { db } from "@/db/db"
import { InsertTodo, SelectTodo, todosTable } from "@/db/schema/todos-schema"
import { ActionState } from "@/types"
import { eq } from "drizzle-orm"

export async function createTodoAction(
  todo: InsertTodo
): Promise<ActionState<SelectTodo>> {
  try {
    const [newTodo] = await db.insert(todosTable).values(todo).returning()
    return {
      isSuccess: true,
      message: "Todo created successfully",
      data: newTodo
    }
  } catch (error) {
    console.error("Error creating todo:", error)
    return { isSuccess: false, message: "Failed to create todo" }
  }
}

export async function getTodosAction(
  userId: string
): Promise<ActionState<SelectTodo[]>> {
  try {
    const todos = await db.query.todos.findMany({
      where: eq(todosTable.userId, userId)
    })
    return {
      isSuccess: true,
      message: "Todos retrieved successfully",
      data: todos
    }
  } catch (error) {
    console.error("Error getting todos:", error)
    return { isSuccess: false, message: "Failed to get todos" }
  }
}

export async function updateTodoAction(
  id: string,
  data: Partial<InsertTodo>
): Promise<ActionState<SelectTodo>> {
  try {
    const [updatedTodo] = await db
      .update(todosTable)
      .set(data)
      .where(eq(todosTable.id, id))
      .returning()

    return {
      isSuccess: true,
      message: "Todo updated successfully",
      data: updatedTodo
    }
  } catch (error) {
    console.error("Error updating todo:", error)
    return { isSuccess: false, message: "Failed to update todo" }
  }
}

export async function deleteTodoAction(id: string): Promise<ActionState<void>> {
  try {
    await db.delete(todosTable).where(eq(todosTable.id, id))
    return {
      isSuccess: true,
      message: "Todo deleted successfully",
      data: undefined
    }
  } catch (error) {
    console.error("Error deleting todo:", error)
    return { isSuccess: false, message: "Failed to delete todo" }
  }
}
```

### Auth Rules

Follow these rules when working on auth.

It uses Clerk for authentication.

#### General Rules

- Import the auth helper with `import { auth } from "@clerk/nextjs/server"` in server components
- await the auth helper in server actions

### Payments Rules

Follow these rules when working on payments.

It uses Stripe for payments.

# Storage Rules

Follow these rules when working with Supabase Storage.

It uses Supabase Storage for file uploads, downloads, and management.

## General Rules

- Always use environment variables for bucket names to maintain consistency across environments
- Never hardcode bucket names in the application code
- Always handle file size limits and allowed file types at the application level
- Use the `upsert` method instead of `upload` when you want to replace existing files
- Always implement proper error handling for storage operations
- Use content-type headers when uploading files to ensure proper file handling

## Organization

### Buckets

- Name buckets in kebab-case: `user-uploads`, `profile-images`
- Create separate buckets for different types of files (e.g., `profile-images`, `documents`, `attachments`)
- Document bucket purposes in a central location
- Set appropriate bucket policies (public/private) based on access requirements
- Implement RLS (Row Level Security) policies for buckets that need user-specific access
- Make sure to let me know instructions for setting up RLS policies on Supabase since you can't do this yourself, including the SQL scripts I need to run in the editor

### File Structure

- Organize files in folders based on their purpose and ownership
- Use predictable, collision-resistant naming patterns
- Structure: `{bucket}/{userId}/{purpose}/{filename}`
- Example: `profile-images/123e4567-e89b/avatar/profile.jpg`
- Include timestamps in filenames when version history is important
- Example: `documents/123e4567-e89b/contracts/2024-02-13-contract.pdf`

## Actions

- When importing storage actions, use `@/actions/storage`
- Name files like `example-storage-actions.ts`
- Include Storage at the end of function names `Ex: uploadFile -> uploadFileStorage`
- Follow the same ActionState pattern as DB actions

Example of a storage action:

```ts
"use server"

import { createClientComponentClient } from "@supabase/auth-helpers-nextjs"
import { ActionState } from "@/types"

export async function uploadFileStorage(
  bucket: string,
  path: string,
  file: File
): Promise<ActionState<{ path: string }>> {
  try {
    const supabase = createClientComponentClient()

    const { data, error } = await supabase.storage
      .from(bucket)
      .upload(path, file, {
        upsert: false,
        contentType: file.type
      })

    if (error) throw error

    return {
      isSuccess: true,
      message: "File uploaded successfully",
      data: { path: data.path }
    }
  } catch (error) {
    console.error("Error uploading file:", error)
    return { isSuccess: false, message: "Failed to upload file" }
  }
}
```

## File Handling

### Upload Rules

- Always validate file size before upload
- Implement file type validation using both extension and MIME type
- Generate unique filenames to prevent collisions
- Set appropriate content-type headers
- Handle existing files appropriately (error or upsert)

Example validation:

```ts
const MAX_FILE_SIZE = 10 * 1024 * 1024 // 10MB
const ALLOWED_TYPES = ["image/jpeg", "image/png", "image/webp"]

function validateFile(file: File): boolean {
  if (file.size > MAX_FILE_SIZE) {
    throw new Error("File size exceeds limit")
  }

  if (!ALLOWED_TYPES.includes(file.type)) {
    throw new Error("File type not allowed")
  }

  return true
}
```

### Download Rules

- Always handle missing files gracefully
- Implement proper error handling for failed downloads
- Use signed URLs for private files

### Delete Rules

- Implement soft deletes when appropriate
- Clean up related database records when deleting files
- Handle bulk deletions carefully
- Verify ownership before deletion
- Always delete all versions/transforms of a file

## Security

### Bucket Policies

- Make buckets private by default
- Only make buckets public when absolutely necessary
- Use RLS policies to restrict access to authorized users
- Example RLS policy:

```sql
CREATE POLICY "Users can only access their own files"
ON storage.objects
FOR ALL
USING (auth.uid()::text = (storage.foldername(name))[1]);
```

### Access Control

- Generate short-lived signed URLs for private files
- Implement proper CORS policies
- Use separate buckets for public and private files
- Never expose internal file paths
- Validate user permissions before any operation

## Error Handling

- Implement specific error types for common storage issues
- Always provide meaningful error messages
- Implement retry logic for transient failures
- Log storage errors separately for monitoring

## Optimization

- Implement progressive upload for large files
- Clean up temporary files and failed uploads
- Use batch operations when handling multiple files

================
File: .env.example
================
# DB
DATABASE_URL=

# Supabase
SUPABASE_URL=
SUPABASE_SERVICE_ROLE_KEY=
SUPABASE_BUCKET_RECEIPTS=

# Auth
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=
CLERK_SECRET_KEY=
NEXT_PUBLIC_CLERK_SIGN_IN_URL=/login
NEXT_PUBLIC_CLERK_SIGN_UP_URL=/signup

# Payments
STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=
NEXT_PUBLIC_STRIPE_PAYMENT_LINK_YEARLY=
NEXT_PUBLIC_STRIPE_PAYMENT_LINK_MONTHLY=

# AI
OPENAI_API_KEY=

================
File: .eslintrc.json
================
/*
Contains the ESLint configuration for the app.
*/

{
  "$schema": "https://json.schemastore.org/eslintrc",
  "root": true,
  "extends": [
    "next/core-web-vitals",
    "prettier",
    "plugin:tailwindcss/recommended"
  ],
  "plugins": ["tailwindcss"],
  "rules": {
    "@next/next/no-img-element": "off",
    "jsx-a11y/alt-text": "off",
    "react-hooks/exhaustive-deps": "off",
    "tailwindcss/enforces-negative-arbitrary-values": "off",
    "tailwindcss/no-contradicting-classname": "off",
    "tailwindcss/no-custom-classname": "off",
    "tailwindcss/no-unnecessary-arbitrary-value": "off",
    "react/no-unescaped-entities": "off"
  },
  "settings": {
    "tailwindcss": { "callees": ["cn", "cva"], "config": "tailwind.config.js" }
  },
  "overrides": [
    { "files": ["*.ts", "*.tsx"], "parser": "@typescript-eslint/parser" }
  ]
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# clerk configuration (can include secrets)
/.clerk/

================
File: .husky/pre-commit
================
#!/usr/bin/env sh

. "$(dirname -- "$0")/_/husky.sh"

npm run lint:fix && npm run format:write && git add .

================
File: .repo_ignore
================
# Package manager caches
**/node_modules/
**/.npm/
**/__pycache__/
**/.pytest_cache/
**/.mypy_cache/

# Build caches
**/.gradle/
**/.nuget/
**/.cargo/
**/.stack-work/
**/.ccache/

# IDE and Editor caches
**/.idea/
**/.vscode/
**/*.swp
**/*~

# Temp files
**/*.tmp
**/*.temp
**/*.bak

**/*.meta
**/package-lock.json

# AI Specific
.repo_ignore
.cursorrules
/.cursor

# Project Specific
**/.github
**/.husky
**/migrations
**/public
**/.next
README.md

================
File: actions/ai-actions.ts
================
/**
 * @description
 * This file contains server actions for AI-driven features in the Learn Kannada app.
 * It integrates with OpenAI to provide grammar explanations, lesson adjustments,
 * and pronunciation assessments, enhancing the learning experience with personalized feedback.
 *
 * Key features:
 * - Grammar Explanations: Generates explanations for grammatical errors
 * - Lesson Difficulty Adjustment: Adapts lessons based on user progress
 * - Pronunciation Assessment: Evaluates spoken input against expected phrases
 *
 * @dependencies
 * - @/lib/ai/openai: Provides the OpenAI client for API calls
 * - @/types: Imports ActionState for consistent return types
 *
 * @notes
 * - All actions are server-side (marked "use server") per project rules
 * - Uses OPENAI_API_KEY from .env.local, set up in Step 1
 * - Handles API errors with fallback messages to ensure user feedback
 * - Assumes lesson content includes phrases for pronunciation comparison
 */

"use server"

import { openai } from "@/lib/ai/openai"
import { ActionState } from "@/types"

/**
 * Generates a grammar explanation for a given sentence using OpenAI.
 * @param {string} sentence - The sentence to analyze
 * @returns {Promise<ActionState<string>>} The explanation or an error message
 */
export async function getGrammarExplanationAction(
  sentence: string
): Promise<ActionState<string>> {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content:
            "You are a Kannada grammar expert. Provide a concise explanation of any grammatical errors in the given sentence, or confirm it’s correct."
        },
        { role: "user", content: sentence }
      ],
      max_tokens: 150
    })

    const explanation = response.choices[0].message.content ?? "No explanation provided."
    return {
      isSuccess: true,
      message: "Grammar explanation generated successfully",
      data: explanation
    }
  } catch (error) {
    console.error("Error generating grammar explanation:", error)
    return {
      isSuccess: false,
      message: "Failed to generate grammar explanation"
    }
  }
}

/**
 * Adjusts lesson difficulty based on user progress using OpenAI.
 * @param {string} userId - The user’s ID
 * @param {number} currentXp - The user’s current XP
 * @returns {Promise<ActionState<string>>} The recommended level or an error
 */
export async function adjustLessonDifficultyAction(
  userId: string,
  currentXp: number
): Promise<ActionState<string>> {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content:
            "You are an adaptive learning system. Based on the user’s XP, recommend a lesson level: beginner (0-100 XP), intermediate (101-300 XP), or advanced (301+ XP)."
        },
        { role: "user", content: `User XP: ${currentXp}` }
      ],
      max_tokens: 50
    })

    const level = response.choices[0].message.content ?? "beginner"
    return {
      isSuccess: true,
      message: "Lesson difficulty adjusted successfully",
      data: level
    }
  } catch (error) {
    console.error("Error adjusting lesson difficulty:", error)
    return {
      isSuccess: false,
      message: "Failed to adjust lesson difficulty"
    }
  }
}

/**
 * Assesses a user’s pronunciation by comparing their transcript to an expected phrase.
 * @param {string} transcript - The user’s spoken input
 * @param {string} expectedPhrase - The correct phrase to compare against
 * @returns {Promise<ActionState<string>>} Feedback on pronunciation accuracy
 */
export async function assessPronunciationAction(
  transcript: string,
  expectedPhrase: string
): Promise<ActionState<string>> {
  // Input validation
  if (!transcript.trim() || !expectedPhrase.trim()) {
    return {
      isSuccess: false,
      message: "Transcript or expected phrase cannot be empty"
    }
  }

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content:
            "You are a pronunciation coach for Kannada. Compare the user’s transcript to the expected phrase and provide feedback on accuracy. If incorrect, suggest improvements."
        },
        {
          role: "user",
          content: `Transcript: "${transcript}"\nExpected: "${expectedPhrase}"`
        }
      ],
      max_tokens: 200
    })

    const feedback = response.choices[0].message.content ?? "No feedback provided."
    return {
      isSuccess: true,
      message: "Pronunciation assessed successfully",
      data: feedback
    }
  } catch (error) {
    console.error("Error assessing pronunciation:", error)
    return {
      isSuccess: false,
      message: "Failed to assess pronunciation. Please try again."
    }
  }
}

================
File: actions/db/chats-actions.ts
================
/**
 * @description
 * This file defines server actions for managing chat messages in the Learn Kannada app.
 * It provides functions to send and retrieve chat messages stored in the Supabase PostgreSQL
 * database using Drizzle ORM. These actions support the peer-to-peer chat system under
 * the social features of the app, enabling learners to practice together.
 *
 * Key features:
 * - Send Message: Creates a new chat message for the authenticated user
 * - Retrieve Messages: Fetches all chat messages (optionally filtered by user ID)
 *
 * @dependencies
 * - @clerk/nextjs/server: Used for authentication via Clerk
 * - drizzle-orm: Provides database query capabilities with Drizzle ORM
 * - @/db/db: Imports the database instance with schema
 * - @/db/schema/chat-messages-schema: Imports chat messages table schema and types
 * - @/types/server-action-types: Imports ActionState type for consistent return values
 *
 * @notes
 * - All actions are server-side only ("use server") per Next.js conventions
 * - Authentication is required for all actions to ensure user-specific operations
 * - getMessagesAction fetches all messages by default; filtering by userId is optional
 * - Designed to support future real-time integration (e.g., Step 18) with Supabase
 * - Date handling relies on schema defaults for createdAt
 */

"use server"

import { auth } from "@clerk/nextjs/server"
import { eq } from "drizzle-orm"
import { db } from "@/db/db"
import {
  InsertChatMessage,
  SelectChatMessage,
  chatMessagesTable
} from "@/db/schema/chat-messages-schema"
import { ActionState } from "@/types/server-action-types"

/**
 * Sends a new chat message for the authenticated user.
 * @param content - The content of the message to send
 * @returns Promise<ActionState<SelectChatMessage>> - Success with new message or error
 */
export async function sendMessageAction(
  content: string
): Promise<ActionState<SelectChatMessage>> {
  // Authenticate the user
  const { userId } = await auth()
  if (!userId) {
    return {
      isSuccess: false,
      message: "Unauthorized: Please sign in to send messages"
    }
  }

  try {
    // Validate input
    if (!content || content.trim().length === 0) {
      return {
        isSuccess: false,
        message: "Message content cannot be empty"
      }
    }

    // Prepare the message data
    const messageData: InsertChatMessage = {
      userId,
      content: content.trim()
    }

    // Insert the message into the database
    const [newMessage] = await db
      .insert(chatMessagesTable)
      .values(messageData)
      .returning()

    return {
      isSuccess: true,
      message: "Message sent successfully",
      data: newMessage
    }
  } catch (error) {
    console.error("Error sending message:", error)
    return {
      isSuccess: false,
      message: "Failed to send message due to a server error"
    }
  }
}

/**
 * Retrieves chat messages, optionally filtered by user ID.
 * @param userIdParam - Optional user ID to filter messages (must match authenticated user if provided)
 * @returns Promise<ActionState<SelectChatMessage[]>> - Success with message list or error
 */
export async function getMessagesAction(
  userIdParam?: string
): Promise<ActionState<SelectChatMessage[]>> {
  // Authenticate the user
  const { userId } = await auth()
  if (!userId) {
    return {
      isSuccess: false,
      message: "Unauthorized: Please sign in to view messages"
    }
  }

  try {
    // If userIdParam is provided, ensure it matches the authenticated user
    if (userIdParam && userIdParam !== userId) {
      return {
        isSuccess: false,
        message: "Forbidden: You can only view your own messages"
      }
    }

    // Fetch messages, filtering by userId if provided, otherwise fetch all
    const messages = userIdParam
      ? await db
          .select()
          .from(chatMessagesTable)
          .where(eq(chatMessagesTable.userId, userIdParam))
      : await db.select().from(chatMessagesTable)

    return {
      isSuccess: true,
      message: "Messages retrieved successfully",
      data: messages
    }
  } catch (error) {
    console.error("Error retrieving messages:", error)
    return {
      isSuccess: false,
      message: "Failed to retrieve messages due to a server error"
    }
  }
}

================
File: actions/db/exercises-actions.ts
================
/**
 * @description
 * This file defines server actions for managing exercises in the Learn Kannada app.
 * It provides functions to create, retrieve, and submit exercises stored in the Supabase
 * PostgreSQL database using Drizzle ORM. These actions support the interactive exercises
 * feature by enabling exercise creation, retrieval by lesson, and basic scoring.
 *
 * Key features:
 * - Create Exercise: Adds a new exercise linked to a lesson
 * - Retrieve Exercises: Fetches all exercises for a given lesson ID
 * - Submit Exercise: Processes user responses and returns a score (basic implementation)
 *
 * @dependencies
 * - @clerk/nextjs/server: Used for authentication via Clerk
 * - drizzle-orm: Provides database query capabilities with Drizzle ORM
 * - @/db/db: Imports the database instance with schema
 * - @/db/schema/exercises-schema: Imports exercises table schema and types
 * - @/types/server-action-types: Imports ActionState type for consistent return values
 *
 * @notes
 * - All actions are server-side only ("use server") per Next.js conventions
 * - Authentication is included for submitExerciseAction; creation/retrieval may assume admin or lesson context
 * - Scoring in submitExerciseAction is basic (correct/incorrect); AI integration is planned for later steps
 * - Date handling relies on schema defaults for createdAt/updatedAt
 * - Assumes exercise content JSON includes a 'correctAnswer' field for scoring
 */

"use server"

import { auth } from "@clerk/nextjs/server"
import { eq } from "drizzle-orm"
import { db } from "@/db/db"
import {
  InsertExercise,
  SelectExercise,
  exercisesTable
} from "@/db/schema/exercises-schema"
import { ActionState } from "@/types/server-action-types"

/**
 * Creates a new exercise linked to a specific lesson.
 * @param exercise - The exercise data to insert (excluding id, createdAt, updatedAt)
 * @returns Promise<ActionState<SelectExercise>> - Success with new exercise or error
 */
export async function createExerciseAction(
  exercise: Omit<InsertExercise, "id" | "createdAt" | "updatedAt">
): Promise<ActionState<SelectExercise>> {
  try {
    // Validate required fields
    if (!exercise.lessonId || !exercise.type || !exercise.content) {
      return {
        isSuccess: false,
        message: "Missing required fields: lessonId, type, or content"
      }
    }

    // Insert the exercise into the database
    const [newExercise] = await db
      .insert(exercisesTable)
      .values(exercise)
      .returning()

    return {
      isSuccess: true,
      message: "Exercise created successfully",
      data: newExercise
    }
  } catch (error) {
    console.error("Error creating exercise:", error)
    return {
      isSuccess: false,
      message: "Failed to create exercise due to a server error"
    }
  }
}

/**
 * Retrieves all exercises associated with a given lesson ID.
 * @param lessonId - The ID of the lesson to fetch exercises for
 * @returns Promise<ActionState<SelectExercise[]>> - Success with exercise list or error
 */
export async function getExercisesByLessonIdAction(
  lessonId: string
): Promise<ActionState<SelectExercise[]>> {
  try {
    // Validate lessonId
    if (!lessonId) {
      return {
        isSuccess: false,
        message: "Lesson ID is required"
      }
    }

    // Fetch exercises for the specified lesson
    const exercises = await db
      .select()
      .from(exercisesTable)
      .where(eq(exercisesTable.lessonId, lessonId))

    return {
      isSuccess: true,
      message: "Exercises retrieved successfully",
      data: exercises
    }
  } catch (error) {
    console.error("Error retrieving exercises:", error)
    return {
      isSuccess: false,
      message: "Failed to retrieve exercises due to a server error"
    }
  }
}

/**
 * Submits a user’s exercise response and returns a basic score.
 * @param exerciseId - The ID of the exercise being submitted
 * @param userResponse - The user’s response to the exercise (string or JSON based on type)
 * @returns Promise<ActionState<{ score: number; feedback: string }>> - Success with score or error
 */
export async function submitExerciseAction(
  exerciseId: string,
  userResponse: string | object
): Promise<ActionState<{ score: number; feedback: string }>> {
  // Authenticate the user
  const { userId } = await auth()
  if (!userId) {
    return {
      isSuccess: false,
      message: "Unauthorized: Please sign in to submit exercises"
    }
  }

  try {
    // Validate inputs
    if (!exerciseId || !userResponse) {
      return {
        isSuccess: false,
        message: "Exercise ID and user response are required"
      }
    }

    // Fetch the exercise to get the correct answer
    const [exercise] = await db
      .select()
      .from(exercisesTable)
      .where(eq(exercisesTable.id, exerciseId))
      .limit(1)

    if (!exercise) {
      return {
        isSuccess: false,
        message: "Exercise not found"
      }
    }

    // Basic scoring logic (assumes content JSON has a 'correctAnswer' field)
    const content = exercise.content as { correctAnswer?: string }
    if (!content.correctAnswer) {
      return {
        isSuccess: false,
        message: "Exercise content lacks a correct answer for scoring"
      }
    }

    // Compare user response with correct answer (string comparison for simplicity)
    const isCorrect =
      typeof userResponse === "string" &&
      userResponse.trim().toLowerCase() === content.correctAnswer.trim().toLowerCase()
    const score = isCorrect ? 1 : 0
    const feedback = isCorrect ? "Correct! Well done." : "Incorrect. Try again!"

    return {
      isSuccess: true,
      message: "Exercise submitted successfully",
      data: { score, feedback }
    }
  } catch (error) {
    console.error("Error submitting exercise:", error)
    return {
      isSuccess: false,
      message: "Failed to submit exercise due to a server error"
    }
  }
}

================
File: actions/db/lessons-actions.ts
================
"use server"

import { auth } from "@clerk/nextjs/server"
import { eq } from "drizzle-orm"
import { db } from "@/db/db"
import { lessonsTable, InsertLesson, SelectLesson } from "@/db/schema/lessons-schema"
import { ActionState } from "@/types"

/**
 * Creates a new lesson in the database.
 */
export async function createLessonAction(
  lesson: InsertLesson
): Promise<ActionState<SelectLesson>> {
  try {
    const { userId } = await auth()
    if (!userId) {
      return { isSuccess: false, message: "Unauthorized: You must be logged in to create a lesson" }
    }

    if (!lesson.title || !lesson.content || !lesson.level) {
      return { isSuccess: false, message: "Missing required fields: title, content, or level" }
    }

    const [newLesson] = await db.insert(lessonsTable).values(lesson).returning()
    return { isSuccess: true, message: "Lesson created successfully", data: newLesson }
  } catch (error) {
    console.error("Error creating lesson:", error)
    return { isSuccess: false, message: "Failed to create lesson due to a server error" }
  }
}

/**
 * Retrieves lessons from the database based on an optional level filter.
 */
export async function getLessonAction(
  level?: "beginner" | "intermediate" | "advanced"
): Promise<ActionState<SelectLesson[]>> {
  try {
    const { userId } = await auth()
    if (!userId) {
      return { isSuccess: false, message: "Unauthorized: You must be logged in to view lessons" }
    }

    const lessons = level
      ? await db.select().from(lessonsTable).where(eq(lessonsTable.level, level))
      : await db.select().from(lessonsTable)

    return { isSuccess: true, message: "Lessons retrieved successfully", data: lessons }
  } catch (error) {
    console.error("Error getting lessons:", error)
    return { isSuccess: false, message: "Failed to retrieve lessons due to a server error" }
  }
}

/**
 * Retrieves lessons by level for the Learn Page.
 */
export async function getLessonsByLevelAction(
  level: "beginner" | "intermediate" | "advanced"
): Promise<ActionState<SelectLesson[]>> {
  return getLessonAction(level)
}

/**
 * Updates an existing lesson in the database.
 */
export async function updateLessonAction(
  id: string,
  data: Partial<InsertLesson>
): Promise<ActionState<SelectLesson>> {
  try {
    const { userId } = await auth()
    if (!userId) {
      return { isSuccess: false, message: "Unauthorized: You must be logged in to update a lesson" }
    }

    if (Object.keys(data).length === 0) {
      return { isSuccess: false, message: "No data provided to update" }
    }

    const [updatedLesson] = await db
      .update(lessonsTable)
      .set(data)
      .where(eq(lessonsTable.id, id))
      .returning()

    if (!updatedLesson) {
      return { isSuccess: false, message: "Lesson not found" }
    }

    return { isSuccess: true, message: "Lesson updated successfully", data: updatedLesson }
  } catch (error) {
    console.error("Error updating lesson:", error)
    return { isSuccess: false, message: "Failed to update lesson due to a server error" }
  }
}

/**
 * Deletes a lesson from the database.
 */
export async function deleteLessonAction(id: string): Promise<ActionState<void>> {
  try {
    const { userId } = await auth()
    if (!userId) {
      return { isSuccess: false, message: "Unauthorized: You must be logged in to delete a lesson" }
    }

    const deleted = await db.delete(lessonsTable).where(eq(lessonsTable.id, id)).returning()

    if (deleted.length === 0) {
      return { isSuccess: false, message: "Lesson not found" }
    }

    return { isSuccess: true, message: "Lesson deleted successfully", data: undefined }
  } catch (error) {
    console.error("Error deleting lesson:", error)
    return { isSuccess: false, message: "Failed to delete lesson due to a server error" }
  }
}

================
File: actions/db/profiles-actions.ts
================
/**
 * @description
 * This file defines server actions for managing user progress in the Learn Kannada app.
 * It provides functions to create, retrieve, and update progress records stored in the
 * Supabase PostgreSQL database using Drizzle ORM. These actions support the progress
 * tracking and gamification features by managing XP, streaks, and badges for users.
 *
 * Key features:
 * - Create Progress: Initializes a new progress record for a user and lesson
 * - Retrieve Progress: Fetches all progress records for a given user
 * - Update Progress: Modifies an existing progress record (e.g., XP, streak, badges)
 *
 * @dependencies
 * - @clerk/nextjs/server: Used for authentication via Clerk
 * - drizzle-orm: Provides database query capabilities with Drizzle ORM
 * - @/db/db: Imports the database instance with schema
 * - @/db/schema/progress-schema: Imports progress table schema and types
 * - @/types/server-action-types: Imports ActionState type for consistent return values
 *
 * @notes
 * - All actions are server-side only ("use server") per Next.js conventions
 * - Authentication is required; unauthenticated requests are rejected
 * - Progress updates use partial updates to allow flexible modifications
 * - Date handling follows backend rules by relying on schema defaults for timestamps
 */

"use server"

import { auth } from "@clerk/nextjs/server"
import { eq } from "drizzle-orm"
import { db } from "@/db/db"
import {
  InsertProgress,
  SelectProgress,
  progressTable
} from "@/db/schema/progress-schema"
import { ActionState } from "@/types/server-action-types"
import { profilesTable } from "@/db/schema/profiles-schema"

/**
 * Creates a new progress record for the authenticated user.
 * @param progress - The progress data to insert (excluding id, createdAt, updatedAt)
 * @returns Promise<ActionState<SelectProgress>> - Success with new progress or error
 */
export async function createProgressAction(
  progress: Omit<InsertProgress, "id" | "createdAt" | "updatedAt">
): Promise<ActionState<SelectProgress>> {
  // Authenticate the user
  const { userId } = await auth()
  if (!userId) {
    return {
      isSuccess: false,
      message: "Unauthorized: Please sign in to create progress"
    }
  }

  try {
    // Ensure userId matches the authenticated user
    const progressData: InsertProgress = {
      ...progress,
      userId,
      xp: progress.xp ?? 0, // Default to 0 if not provided
      streak: progress.streak ?? 0, // Default to 0 if not provided
      badges: progress.badges ?? [] // Default to empty array if not provided
    }

    // Insert the progress record into the database
    const [newProgress] = await db
      .insert(progressTable)
      .values(progressData)
      .returning()

    return {
      isSuccess: true,
      message: "Progress created successfully",
      data: newProgress
    }
  } catch (error) {
    console.error("Error creating progress:", error)
    return {
      isSuccess: false,
      message: "Failed to create progress due to a server error"
    }
  }
}

/**
 * Retrieves all progress records for the authenticated user.
 * @param userIdParam - Optional user ID to fetch progress for (must match auth user)
 * @returns Promise<ActionState<SelectProgress[]>> - Success with progress list or error
 */
export async function getProgressByUserIdAction(
  userIdParam?: string
): Promise<ActionState<SelectProgress[]>> {
  // Authenticate the user
  const { userId } = await auth()
  if (!userId) {
    return {
      isSuccess: false,
      message: "Unauthorized: Please sign in to view progress"
    }
  }

  // If userIdParam is provided, ensure it matches the authenticated user
  if (userIdParam && userIdParam !== userId) {
    return {
      isSuccess: false,
      message: "Forbidden: You can only view your own progress"
    }
  }

  try {
    // Fetch all progress records for the authenticated user
    const progressRecords = await db
      .select()
      .from(progressTable)
      .where(eq(progressTable.userId, userId))

    return {
      isSuccess: true,
      message: "Progress retrieved successfully",
      data: progressRecords
    }
  } catch (error) {
    console.error("Error retrieving progress:", error)
    return {
      isSuccess: false,
      message: "Failed to retrieve progress due to a server error"
    }
  }
}

/**
 * Updates an existing progress record for the authenticated user.
 * @param id - The ID of the progress record to update
 * @param data - Partial progress data to update (e.g., xp, streak, badges)
 * @returns Promise<ActionState<SelectProgress>> - Success with updated progress or error
 */
export async function updateProgressAction(
  id: string,
  data: Partial<Omit<InsertProgress, "id" | "userId" | "createdAt" | "updatedAt">>
): Promise<ActionState<SelectProgress>> {
  // Authenticate the user
  const { userId } = await auth();
  if (!userId) {
    return {
      isSuccess: false,
      message: "Unauthorized: Please sign in to update progress"
    };
  }

  try {
    // Try to update progress directly and return the updated record
    const [updatedProgress] = await db
      .update(progressTable)
      .set(data)
      .where(eq(progressTable.id, id))
      .returning();

    if (!updatedProgress) {
      return {
        isSuccess: false,
        message: "Progress record not found or unauthorized"
      };
    }

    return {
      isSuccess: true,
      message: "Progress updated successfully",
      data: updatedProgress
    };
  } catch (error) {
    console.error("Error updating progress:", error);
    return {
      isSuccess: false,
      message: "Failed to update progress due to a server error"
    };
  }
}

export async function updateProfileAction(userId: string, data: any) {
    // Implementation for updating a profile based on userId
    try {
        const updatedProfile = await db
            .update(profilesTable) // Now profilesTable should be defined
            .set(data)
            .where(eq(profilesTable.userId, userId))
            .returning();

        return {
            isSuccess: true,
            message: "Profile updated successfully",
            data: updatedProfile
        };
    } catch (error) {
        console.error("Error updating profile:", error);
        return {
            isSuccess: false,
            message: "Failed to update profile"
        };
    }
}

export async function updateProfileByStripeCustomerIdAction(customerId: string, data: any) {
    // Implementation for updating a profile based on Stripe customer ID
    try {
        const updatedProfile = await db
            .update(profilesTable) // Assuming profilesTable is defined
            .set(data)
            .where(eq(profilesTable.stripeCustomerId, customerId))
            .returning();

        return {
            isSuccess: true,
            message: "Profile updated successfully by Stripe customer ID",
            data: updatedProfile
        };
    } catch (error) {
        console.error("Error updating profile by Stripe customer ID:", error);
        return {
            isSuccess: false,
            message: "Failed to update profile by Stripe customer ID"
        };
    }
}

export async function createProfileAction(data: any) {
    // Implementation for creating a profile
    try {
        const newProfile = await db
            .insert(profilesTable) // Assuming profilesTable is defined
            .values(data)
            .returning();

        return {
            isSuccess: true,
            message: "Profile created successfully",
            data: newProfile
        };
    } catch (error) {
        console.error("Error creating profile:", error);
        return {
            isSuccess: false,
            message: "Failed to create profile"
        };
    }
}

export async function getProfileByUserIdAction(userId: string) {
    // Implementation for retrieving a profile by userId
    try {
        const profiles = await db
            .select()
            .from(profilesTable)
            .where(eq(profilesTable.userId, userId));

        if (profiles.length === 0) {
            return {
                isSuccess: false,
                message: "Profile not found"
            };
        }

        return {
            isSuccess: true,
            message: "Profile retrieved successfully",
            data: profiles[0] // Return the first profile found
        };
    } catch (error) {
        console.error("Error retrieving profile:", error);
        return {
            isSuccess: false,
            message: "Failed to retrieve profile"
        };
    }
}

================
File: actions/db/progress-actions.ts
================
/**
 * @description
 * This file contains server actions for managing user progress in the Learn Kannada app.
 * It provides CRUD operations for progress records and gamification logic to track XP,
 * streaks, and badges, enhancing user engagement through motivational features.
 *
 * Key features:
 * - Create, read, and update progress records
 * - Gamification: Calculates XP, increments streaks, and awards badges
 * - Integrates with Supabase via Drizzle ORM for database operations
 *
 * @dependencies
 * - @/db/db: Provides the Drizzle ORM database instance
 * - @/db/schema/progress-schema: Imports progressTable and types
 * - @/types: Imports ActionState for consistent return types
 * - drizzle-orm: Provides eq and desc for query conditions and ordering
 *
 * @notes
 * - Marked "use server" per backend rules
 * - XP is awarded based on exercise completion (10 XP per submission)
 * - Streaks increment if updated within 24 hours of last update
 * - Badges are awarded at XP thresholds: Learner (50), Scholar (150), Master (300)
 * - No migrations generated here; handled externally
 */

"use server"

import { db } from "@/db/db"
import { InsertProgress, SelectProgress, progressTable } from "@/db/schema/progress-schema"
import { ActionState } from "@/types"
import { eq, desc } from "drizzle-orm"

// XP per exercise completion
const XP_PER_EXERCISE = 10

// Badge thresholds and names
const BADGE_THRESHOLDS: { [key: number]: string } = {
  50: "Learner",
  150: "Scholar",
  300: "Master"
}

// 24-hour window for streak increment (in milliseconds)
const STREAK_WINDOW = 24 * 60 * 60 * 1000

/**
 * Creates a new progress record for a user.
 * @param {InsertProgress} progress - The progress data to insert
 * @returns {Promise<ActionState<SelectProgress>>} The created progress record or error
 */
export async function createProgressAction(
  progress: InsertProgress
): Promise<ActionState<SelectProgress>> {
  try {
    const [newProgress] = await db.insert(progressTable).values(progress).returning()
    return {
      isSuccess: true,
      message: "Progress created successfully",
      data: newProgress
    }
  } catch (error) {
    console.error("Error creating progress:", error)
    return { isSuccess: false, message: "Failed to create progress" }
  }
}

/**
 * Retrieves all progress records for a user.
 * @param {string} userId - The user’s ID
 * @returns {Promise<ActionState<SelectProgress[]>>} The user’s progress records or error
 */
export async function getProgressByUserIdAction(
  userId: string
): Promise<ActionState<SelectProgress[]>> {
  try {
    const progressRecords = await db
      .select()
      .from(progressTable)
      .where(eq(progressTable.userId, userId))
    return {
      isSuccess: true,
      message: "Progress retrieved successfully",
      data: progressRecords
    }
  } catch (error) {
    console.error("Error retrieving progress:", error)
    return { isSuccess: false, message: "Failed to retrieve progress" }
  }
}

/**
 * Updates a progress record with new data.
 * @param {string} id - The progress record ID
 * @param {Partial<InsertProgress>} data - The data to update
 * @returns {Promise<ActionState<SelectProgress>>} The updated progress record or error
 */
export async function updateProgressAction(
  id: string,
  data: Partial<InsertProgress>
): Promise<ActionState<SelectProgress>> {
  try {
    const [updatedProgress] = await db
      .update(progressTable)
      .set(data)
      .where(eq(progressTable.id, id))
      .returning()

    if (!updatedProgress) {
      return { isSuccess: false, message: "Progress record not found" }
    }

    return {
      isSuccess: true,
      message: "Progress updated successfully",
      data: updatedProgress
    }
  } catch (error) {
    console.error("Error updating progress:", error)
    return { isSuccess: false, message: "Failed to update progress" }
  }
}

/**
 * Updates a user’s progress with gamification logic after an exercise submission.
 * @param {string} userId - The user’s ID
 * @param {string} lessonId - The lesson ID (optional)
 * @returns {Promise<ActionState<SelectProgress>>} The updated progress record or error
 */
export async function updateProgressWithGamificationAction(
  userId: string,
  lessonId?: string
): Promise<ActionState<SelectProgress>> {
  try {
    // Fetch the latest progress record for the user
    const existingProgressRecords = await db
      .select()
      .from(progressTable)
      .where(eq(progressTable.userId, userId))
      .orderBy(desc(progressTable.updatedAt))
      .limit(1)

    const existingProgress = existingProgressRecords[0]

    // Calculate new XP
    const newXp = (existingProgress?.xp || 0) + XP_PER_EXERCISE

    // Calculate streak
    const now = new Date()
    let newStreak = existingProgress?.streak || 0
    if (existingProgress && existingProgress.updatedAt) {
      const lastUpdate = new Date(existingProgress.updatedAt)
      const timeDiff = now.getTime() - lastUpdate.getTime()
      if (timeDiff <= STREAK_WINDOW) {
        newStreak += 1
      } else if (timeDiff > STREAK_WINDOW * 2) {
        newStreak = 1 // Reset streak if more than 48 hours have passed
      }
    } else {
      newStreak = 1 // First activity starts the streak
    }

    // Calculate badges
    let badges: string[] = existingProgress?.badges
      ? (existingProgress.badges as string[])
      : []
    for (const [threshold, badgeName] of Object.entries(BADGE_THRESHOLDS)) {
      if (newXp >= Number(threshold) && !badges.includes(badgeName)) {
        badges.push(badgeName)
      }
    }

    // Prepare updated progress data
    const updatedData: Partial<InsertProgress> = {
      xp: newXp,
      streak: newStreak,
      badges,
      updatedAt: now,
      ...(lessonId && { lessonId }) // Update lessonId if provided
    }

    let updatedProgress: SelectProgress

    if (existingProgress) {
      // Update existing record
      const [result] = await db
        .update(progressTable)
        .set(updatedData)
        .where(eq(progressTable.id, existingProgress.id))
        .returning()
      updatedProgress = result
    } else {
      // Create new record if none exists
      const [result] = await db
        .insert(progressTable)
        .values({
          userId,
          lessonId,
          xp: newXp,
          streak: newStreak,
          badges,
          createdAt: now,
          updatedAt: now
        })
        .returning()
      updatedProgress = result
    }

    return {
      isSuccess: true,
      message: "Progress updated with gamification successfully",
      data: updatedProgress
    }
  } catch (error) {
    console.error("Error updating progress with gamification:", error)
    return { isSuccess: false, message: "Failed to update progress with gamification" }
  }
}

================
File: actions/storage/offline-actions.ts
================
/**
 * @description
 * This file defines server actions for managing offline lesson downloads in the Learn Kannada app.
 * It uses Supabase Storage to generate signed URLs for lesson content, enabling offline access.
 * All actions are server-side, adhering to the project’s backend and storage rules.
 *
 * Key features:
 * - Download Lessons: Generates a signed URL for a lesson’s JSON content
 * - Security: Uses Clerk auth and RLS policies to restrict access to user-owned files
 * - Type Safety: Defines interfaces for inputs and outputs
 *
 * @dependencies
 * - @supabase/supabase-js: Supabase client for storage operations
 * - @clerk/nextjs/server: Clerk auth helper for user authentication
 * - @/types/server-action-types: ActionState type for consistent return values
 * - @/db/schema/lessons-schema: SelectLesson type for lesson metadata
 *
 * @notes
 * - Assumes a `lessons` bucket exists in Supabase with RLS policy applied (user instructions provided)
 * - Lesson content is stored as JSON files in `{userId}/{lessonId}.json` format
 * - Signed URLs are valid for 1 hour; adjust expiration as needed
 * - No direct client-side storage access; all operations are server-side per rules
 * - Error handling covers auth, storage access, and file existence
 */

"use server"

import { createClient } from "@supabase/supabase-js"
import { auth } from "@clerk/nextjs/server"
import { ActionState } from "@/types/server-action-types"
import { SelectLesson } from "@/db/schema/lessons-schema"

// Define parameters for downloading a lesson
interface DownloadLessonParams {
  lessonId: string // UUID of the lesson to download
}

// Define response type for lesson download
interface DownloadLessonResponse {
  url: string // Signed URL for downloading the lesson content
}

/**
 * Generates a signed URL for downloading a lesson’s content from Supabase Storage.
 * @param {DownloadLessonParams} params - Lesson ID to download
 * @returns {Promise<ActionState<DownloadLessonResponse>>} Success/failure with signed URL
 */
export async function downloadLessonStorage({
  lessonId
}: DownloadLessonParams): Promise<ActionState<DownloadLessonResponse>> {
  try {
    // Authenticate user with Clerk
    const { userId } = await auth()
    if (!userId) {
      return {
        isSuccess: false,
        message: "User not authenticated"
      }
    }

    // Validate lessonId (basic UUID check)
    if (!lessonId || !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(lessonId)) {
      return {
        isSuccess: false,
        message: "Invalid lesson ID"
      }
    }

    // Initialize Supabase client with environment variables
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!,
      { auth: { autoRefreshToken: false, persistSession: false } }
    )

    // Define bucket and file path per storage rules: {bucket}/{userId}/{purpose}/{filename}
    const bucketName = process.env.SUPABASE_LESSONS_BUCKET || "lessons"
    const filePath = `${userId}/${lessonId}.json`

    // Generate a signed URL for the lesson file
    const { data, error } = await supabase.storage
      .from(bucketName)
      .createSignedUrl(filePath, 3600) // URL expires in 1 hour

    if (error) {
      throw error
    }

    if (!data?.signedUrl) {
      throw new Error("Signed URL not generated")
    }

    return {
      isSuccess: true,
      message: "Lesson download URL generated successfully",
      data: { url: data.signedUrl }
    }
  } catch (error) {
    console.error("Error generating lesson download URL:", error)
    return {
      isSuccess: false,
      message: "Failed to generate lesson download URL. Please try again."
    }
  }
}

================
File: actions/stripe-actions.ts
================
/**
 * @description
 * This file defines server actions for Stripe payment operations in the Learn Kannada app.
 * It handles creating checkout sessions for tutor bookings, updating customer details after one-time payments,
 * and managing subscription status changes. All actions are server-side, adhering to the project's backend and payments rules.
 *
 * Key features:
 * - Tutor Checkout: Creates a Stripe checkout session for booking live tutor sessions
 * - Customer Update: Updates user profile with Stripe customer ID after a one-time payment
 * - Subscription Management: Updates user profile based on Stripe webhook events
 * - Type Safety: Uses TypeScript interfaces for inputs and outputs
 *
 * @dependencies
 * - @/lib/stripe: Stripe instance initialized with API key
 * - @/db/db: Drizzle ORM instance for database access
 * - @/db/schema/profiles-schema: Profiles table schema for membership updates
 * - @/types/server-action-types: ActionState type for consistent return values
 * - drizzle-orm: For database operations (eq for querying)
 *
 * @notes
 * - Assumes STRIPE_SECRET_KEY is set in .env.local (from initial setup)
 * - Tutor session price ID is a placeholder; must be replaced with actual Stripe product ID
 * - Success and cancel URLs use NEXT_PUBLIC_BASE_URL from .env.local
 * - No direct client-side Stripe interaction; all logic is server-side per rules
 * - Error handling logs to console and returns meaningful messages
 */

"use server"

import { stripe } from "@/lib/stripe"
import { db } from "@/db/db"
import { profilesTable, InsertProfile } from "@/db/schema/profiles-schema"
import { ActionState } from "@/types/server-action-types"
import { eq } from "drizzle-orm"

// Define parameters for creating a tutor checkout session
export interface CreateTutorCheckoutSessionParams {
  userId: string
  successUrl: string
  cancelUrl: string
}

// Define response type for tutor checkout session
interface CheckoutSessionResponse {
  url: string // URL to redirect the user to for checkout
}

/**
 * Creates a Stripe checkout session for booking a tutor session.
 * @param {CreateTutorCheckoutSessionParams} params - User ID and redirect URLs
 * @returns {Promise<ActionState<CheckoutSessionResponse>>} Success/failure with checkout URL
 */
export async function createTutorCheckoutSessionAction({
  userId,
  successUrl,
  cancelUrl
}: CreateTutorCheckoutSessionParams): Promise<ActionState<CheckoutSessionResponse>> {
  try {
    // Create a Stripe checkout session
    const session = await stripe.checkout.sessions.create({
      payment_method_types: ["card"],
      line_items: [
        {
          // Placeholder price ID; replace with actual Stripe price ID for tutor session
          price: "price_tutor_session_placeholder", // TODO: Update with real price ID
          quantity: 1
        }
      ],
      mode: "payment",
      success_url: successUrl,
      cancel_url: cancelUrl,
      metadata: { userId } // Store userId for webhook verification if needed
    })

    if (!session.url) {
      throw new Error("Stripe session URL not generated")
    }

    return {
      isSuccess: true,
      message: "Checkout session created successfully",
      data: { url: session.url }
    }
  } catch (error) {
    console.error("Error creating tutor checkout session:", error)
    return {
      isSuccess: false,
      message: "Failed to create checkout session. Please try again."
    }
  }
}

/**
 * Updates user profile with Stripe customer ID after a one-time payment (e.g., tutor session).
 * @param {string} userId - Clerk user ID
 * @param {string} customerId - Stripe customer ID
 * @returns {Promise<ActionState<void>>} Success/failure with no data
 */
export async function updateStripeCustomerAction(
  userId: string,
  customerId: string
): Promise<ActionState<void>> {
  try {
    const profileUpdates: Partial<InsertProfile> = {
      stripeCustomerId: customerId
      // No subscription ID or membership change for one-time payments
    }

    await db
      .update(profilesTable)
      .set(profileUpdates)
      .where(eq(profilesTable.userId, userId))

    return {
      isSuccess: true,
      message: "Customer details updated successfully",
      data: undefined
    }
  } catch (error) {
    console.error("Error updating customer details:", error)
    return {
      isSuccess: false,
      message: "Failed to update customer details"
    }
  }
}

/**
 * Updates user profile based on Stripe subscription events from webhooks.
 * @param {string} userId - Clerk user ID
 * @param {string} subscriptionId - Stripe subscription ID
 * @param {string} customerId - Stripe customer ID
 * @returns {Promise<ActionState<void>>} Success/failure with no data
 */
export async function manageSubscriptionStatusChange(
  userId: string,
  subscriptionId: string,
  customerId: string
): Promise<ActionState<void>> {
  try {
    const profileUpdates: Partial<InsertProfile> = {
      stripeSubscriptionId: subscriptionId,
      stripeCustomerId: customerId,
      membership: "pro" // Upgrade to pro on successful subscription
    }

    await db
      .update(profilesTable)
      .set(profileUpdates)
      .where(eq(profilesTable.userId, userId))

    return {
      isSuccess: true,
      message: "Subscription status updated successfully",
      data: undefined
    }
  } catch (error) {
    console.error("Error updating subscription status:", error)
    return {
      isSuccess: false,
      message: "Failed to update subscription status"
    }
  }
}

================
File: app/(auth)/layout.tsx
================
/*
This server layout provides a centered layout for (auth) pages.
*/

"use server"

interface AuthLayoutProps {
  children: React.ReactNode
}

export default async function AuthLayout({ children }: AuthLayoutProps) {
  return (
    <div className="flex h-screen items-center justify-center">{children}</div>
  )
}

================
File: app/(auth)/login/[[...login]]/page.tsx
================
/*
This client page provides the login form from Clerk.
*/

"use client"

import { SignIn } from "@clerk/nextjs"
import { dark } from "@clerk/themes"
import { useTheme } from "next-themes"

export default function LoginPage() {
  const { theme } = useTheme()

  return (
    <SignIn
      forceRedirectUrl="/"
      appearance={{ baseTheme: theme === "dark" ? dark : undefined }}
    />
  )
}

================
File: app/(auth)/signup/[[...signup]]/page.tsx
================
/*
This client page provides the signup form from Clerk.
*/

"use client"

import { SignUp } from "@clerk/nextjs"
import { dark } from "@clerk/themes"
import { useTheme } from "next-themes"

export default function SignUpPage() {
  const { theme } = useTheme()

  return (
    <SignUp
      forceRedirectUrl="/"
      appearance={{ baseTheme: theme === "dark" ? dark : undefined }}
    />
  )
}

================
File: app/(marketing)/about/page.tsx
================
/*
This server page displays information about the company, mission, and team.
*/

"use server"

import { Card, CardContent } from "@/components/ui/card"

export default async function AboutPage() {
  return (
    <div className="container mx-auto py-12">
      <h1 className="mb-8 text-center text-4xl font-bold">About Us</h1>

      <div className="space-y-8">
        <Card>
          <CardContent className="pt-6">
            <h2 className="mb-4 text-2xl font-semibold">Our Story</h2>
            <p className="text-muted-foreground">
              We are passionate about building tools that help people work
              smarter and achieve more. Our platform combines cutting-edge
              technology with intuitive design to create a seamless experience
              for our users.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <h2 className="mb-4 text-2xl font-semibold">Our Mission</h2>
            <p className="text-muted-foreground">
              Our mission is to empower individuals and organizations with
              innovative solutions that drive productivity and success. We
              believe in creating technology that adapts to how people work, not
              the other way around.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <h2 className="mb-4 text-2xl font-semibold">Core Values</h2>
            <ul className="text-muted-foreground list-inside list-disc space-y-2">
              <li>Innovation in everything we do</li>
              <li>Customer success is our success</li>
              <li>Transparency and trust</li>
              <li>Continuous improvement</li>
            </ul>
          </CardContent>
        </Card>
      </div>
    </div>
  )
}

================
File: app/(marketing)/contact/_components/contact-form.tsx
================
"use client"

import { Button } from "@/components/ui/button"
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage
} from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { zodResolver } from "@hookform/resolvers/zod"
import { useForm } from "react-hook-form"
import * as z from "zod"

const formSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Please enter a valid email address"),
  message: z.string().min(10, "Message must be at least 10 characters")
})

export default function ContactForm() {
  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: { name: "", email: "", message: "" }
  })

  async function onSubmit(values: z.infer<typeof formSchema>) {
    // In a real app, you would handle the form submission here
    // For example, sending the data to your API route
    console.log(values)
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Name</FormLabel>
              <FormControl>
                <Input placeholder="Your name" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <FormControl>
                <Input placeholder="you@example.com" type="email" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="message"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Message</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="How can we help?"
                  className="min-h-[120px]"
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button type="submit" className="w-full">
          Send Message
        </Button>
      </form>
    </Form>
  )
}

================
File: app/(marketing)/contact/page.tsx
================
/*
This server page displays a contact form for users to get in touch.
*/

"use server"

import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle
} from "@/components/ui/card"
import ContactForm from "./_components/contact-form"

export default async function ContactPage() {
  return (
    <div className="container mx-auto max-w-5xl px-4 py-12">
      <div className="mx-auto mb-12 max-w-2xl text-center">
        <h1 className="mb-4 text-4xl font-bold">Contact Us</h1>
        <p className="text-muted-foreground">
          Have a question or need help? Get in touch with our team.
        </p>
      </div>

      <Card className="mx-auto max-w-xl">
        <CardHeader>
          <CardTitle>Send us a message</CardTitle>
          <CardDescription>
            Fill out the form below and we'll get back to you as soon as
            possible.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <ContactForm />
        </CardContent>
      </Card>
    </div>
  )
}

================
File: app/(marketing)/features/page.tsx
================
/*
This server page displays the main features and capabilities of the product.
*/

"use server"

import { Card, CardContent } from "@/components/ui/card"
import { BarChart, Clock, Settings, Shield, Users, Zap } from "lucide-react"

interface FeatureProps {
  title: string
  description: string
  icon: React.ReactNode
}

function Feature({ title, description, icon }: FeatureProps) {
  return (
    <Card>
      <CardContent className="flex items-start gap-4 pt-6">
        <div className="bg-primary text-primary-foreground rounded-lg p-2">
          {icon}
        </div>
        <div>
          <h3 className="mb-2 font-semibold">{title}</h3>
          <p className="text-muted-foreground text-sm">{description}</p>
        </div>
      </CardContent>
    </Card>
  )
}

export default async function FeaturesPage() {
  const features: FeatureProps[] = [
    {
      title: "Lightning Fast",
      description:
        "Optimized performance for quick load times and smooth interactions.",
      icon: <Zap className="size-5" />
    },
    {
      title: "Enterprise Security",
      description:
        "Bank-grade encryption and security measures to protect your data.",
      icon: <Shield className="size-5" />
    },
    {
      title: "Customizable",
      description:
        "Flexible settings and configurations to match your workflow.",
      icon: <Settings className="size-5" />
    },
    {
      title: "Team Collaboration",
      description:
        "Built-in tools for seamless team coordination and communication.",
      icon: <Users className="size-5" />
    },
    {
      title: "Real-time Updates",
      description: "Stay synchronized with instant updates and notifications.",
      icon: <Clock className="size-5" />
    },
    {
      title: "Advanced Analytics",
      description:
        "Comprehensive insights and reporting to track your progress.",
      icon: <BarChart className="size-5" />
    }
  ]

  return (
    <div className="container mx-auto py-12">
      <h1 className="mb-8 text-center text-4xl font-bold">Features</h1>
      <p className="text-muted-foreground mx-auto mb-12 max-w-2xl text-center">
        Discover the powerful features that make our platform the perfect
        solution for your needs.
      </p>

      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        {features.map((feature, index) => (
          <Feature key={index} {...feature} />
        ))}
      </div>
    </div>
  )
}

================
File: app/(marketing)/layout.tsx
================
/*
This server layout provides a shared header and basic structure for (marketing) routes.
*/

"use server"

import { Footer } from "@/components/landing/footer"
import Header from "@/components/landing/header"

export default async function MarketingLayout({
  children
}: {
  children: React.ReactNode
}) {
  return (
    <div className="flex min-h-screen flex-col">
      <Header />
      <div className="flex-1">{children}</div>
      <Footer />
    </div>
  )
}

================
File: app/(marketing)/page.tsx
================
/*
This server page is the marketing homepage.
*/

"use server"

import { HeroSection } from "@/components/landing/hero"

export default async function HomePage() {
  return (
    <div className="pb-20">
      <HeroSection />
    </div>
  )
}

================
File: app/(marketing)/pricing/page.tsx
================
/*
This server page displays pricing options for the product, integrating Stripe payment links.
*/

"use server"

import { Button } from "@/components/ui/button"
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle
} from "@/components/ui/card"
import { cn } from "@/lib/utils"
import { auth } from "@clerk/nextjs/server"
import { Check } from "lucide-react"

export default async function PricingPage() {
  const { userId } = await auth()

  const features = [
    "All core features",
    "Priority support",
    "Advanced analytics",
    "Custom integrations",
    "API access",
    "Team collaboration"
  ]

  return (
    <div className="container mx-auto max-w-5xl px-4 py-12">
      <div className="mx-auto mb-12 max-w-2xl text-center">
        <h1 className="mb-4 text-4xl font-bold">Simple, Transparent Pricing</h1>
        <p className="text-muted-foreground">
          Choose the plan that best fits your needs. All plans include a 14-day
          free trial.
        </p>
      </div>

      <div className="mx-auto grid max-w-4xl grid-cols-1 gap-8 md:grid-cols-2">
        <PricingCard
          title="Monthly Plan"
          price="$10"
          description="Perfect for individuals and small teams"
          buttonText="Subscribe Monthly"
          buttonLink={
            process.env.NEXT_PUBLIC_STRIPE_PAYMENT_LINK_MONTHLY || "#"
          }
          features={features}
          userId={userId}
          popular={false}
        />
        <PricingCard
          title="Yearly Plan"
          price="$100"
          description="Save 17% with annual billing"
          buttonText="Subscribe Yearly"
          buttonLink={process.env.NEXT_PUBLIC_STRIPE_PAYMENT_LINK_YEARLY || "#"}
          features={features}
          userId={userId}
          popular={true}
        />
      </div>

      <p className="text-muted-foreground mt-8 text-center text-sm">
        All prices are in USD. Need a custom plan?{" "}
        <a href="/contact" className="font-medium underline underline-offset-4">
          Contact us
        </a>
      </p>
    </div>
  )
}

interface PricingCardProps {
  title: string
  price: string
  description: string
  buttonText: string
  buttonLink: string
  features: string[]
  userId: string | null
  popular: boolean
}

function PricingCard({
  title,
  price,
  description,
  buttonText,
  buttonLink,
  features,
  userId,
  popular
}: PricingCardProps) {
  const finalButtonLink = userId
    ? `${buttonLink}?client_reference_id=${userId}`
    : buttonLink

  return (
    <Card
      className={cn(
        "relative flex h-full flex-col",
        popular && "border-primary shadow-lg"
      )}
    >
      {popular && (
        <div className="bg-primary text-primary-foreground absolute -top-4 left-1/2 -translate-x-1/2 rounded-full px-3 py-1 text-sm font-medium">
          Most Popular
        </div>
      )}

      <CardHeader>
        <CardTitle className="text-2xl">{title}</CardTitle>
        <CardDescription>{description}</CardDescription>
      </CardHeader>

      <CardContent className="grow">
        <div className="mb-6 flex items-baseline justify-center gap-x-2">
          <span className="text-5xl font-bold">{price}</span>
          <span className="text-muted-foreground">/month</span>
        </div>

        <ul className="space-y-3">
          {features.map((feature, index) => (
            <li key={index} className="flex items-center gap-x-2">
              <Check className="text-primary size-4" />
              <span className="text-muted-foreground text-sm">{feature}</span>
            </li>
          ))}
        </ul>
      </CardContent>

      <CardFooter>
        <Button
          className={cn(
            "w-full",
            popular && "bg-primary text-primary-foreground hover:bg-primary/90"
          )}
          asChild
        >
          <a
            href={finalButtonLink}
            className={cn(
              "inline-flex items-center justify-center",
              finalButtonLink === "#" && "pointer-events-none opacity-50"
            )}
          >
            {buttonText}
          </a>
        </Button>
      </CardFooter>
    </Card>
  )
}

================
File: app/api/stripe/webhooks/route.ts
================
/**
 * @description
 * This file defines the Stripe webhook endpoint for the Learn Kannada app.
 * It handles incoming Stripe events, such as checkout session completions,
 * to update user profiles accordingly. This is a server-side API route.
 *
 * Key features:
 * - Webhook Verification: Validates Stripe signatures for security
 * - Event Handling: Processes checkout.session.completed for tutor sessions
 * - Integration: Updates user profile via server actions
 *
 * @dependencies
 * - @/actions/stripe-actions: For updating customer details (updateStripeCustomerAction)
 * - @/lib/stripe: Stripe instance for webhook verification
 * - next/headers: For accessing request headers
 *
 * @notes
 * - Requires STRIPE_WEBHOOK_SECRET in .env.local for signature verification
 * - Returns appropriate HTTP responses (200 for success, 400 for errors)
 * - Logs errors to console for debugging; consider a proper logging solution in production
 * - Assumes userId is stored in checkout session metadata from createTutorCheckoutSessionAction
 */

import { NextResponse } from "next/server"
import {
  manageSubscriptionStatusChange,
  updateStripeCustomerAction
} from "@/actions/stripe-actions"
import { stripe } from "@/lib/stripe"
import { headers } from "next/headers"

/**
 * Handles POST requests to the Stripe webhook endpoint.
 * @param {Request} request - Incoming webhook request from Stripe
 * @returns {Promise<NextResponse>} HTTP response indicating success or failure
 */
export async function POST(request: Request) {
  const body = await request.text()
  const signature = (await headers()).get("Stripe-Signature") as string

  if (!process.env.STRIPE_WEBHOOK_SECRET) {
    console.error("STRIPE_WEBHOOK_SECRET is not set in .env.local")
    return NextResponse.json(
      { error: "Webhook secret not configured" },
      { status: 400 }
    )
  }

  let event
  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET
    )
  } catch (error) {
    console.error("Webhook signature verification failed:", error)
    return NextResponse.json(
      { error: "Webhook signature verification failed" },
      { status: 400 }
    )
  }

  try {
    switch (event.type) {
      case "checkout.session.completed": {
        const session = event.data.object
        const userId = session.metadata?.userId
        const customerId = session.customer as string

        if (!userId || !customerId) {
          console.error("Missing userId or customerId in session:", session)
          return NextResponse.json(
            { error: "Invalid session data" },
            { status: 400 }
          )
        }

        // Update customer details for one-time payment (e.g., tutor session)
        const result = await updateStripeCustomerAction(userId, customerId)
        if (!result.isSuccess) {
          console.error("Failed to update customer:", result.message)
          return NextResponse.json({ error: result.message }, { status: 400 })
        }
        break
      }
      // Add other event types (e.g., subscription events) as needed
      default:
        console.log(`Unhandled event type: ${event.type}`)
    }

    return NextResponse.json({ received: true }, { status: 200 })
  } catch (error) {
    console.error("Error processing webhook event:", error)
    return NextResponse.json(
      { error: "Failed to process webhook" },
      { status: 400 }
    )
  }
}

================
File: app/community/chat/page.tsx
================
/**
 * @description
 * This client component serves as the community chat page for the Learn Kannada app.
 * It provides a real-time peer-to-peer chat interface where users can send and receive messages,
 * supporting the social feature for learners to practice together.
 *
 * Key features:
 * - Real-time message updates using Supabase subscriptions
 * - Displays a scrollable list of chat messages
 * - Allows users to send messages via sendMessageAction
 * - Clean, responsive UI with Tailwind CSS and Shadcn components
 * - Integrates Clerk authentication for user identification
 *
 * @dependencies
 * - @clerk/nextjs: For Clerk auth hooks (useUser)
 * - @supabase/supabase-js: For real-time Supabase client
 * - @/actions/db/chats-actions: Server action to send messages
 * - @/components/ui/input: Shadcn Input for message input
 * - @/components/ui/button: Shadcn Button for sending messages
 * - @/db/schema/chat-messages-schema: Types for chat messages
 * - lucide-react: Provides icons (e.g., Send)
 * - react: For state and effect management
 *
 * @notes
 * - Marked "use client" as it's a client component with real-time interactivity
 * - Assumes sendMessageAction and getMessagesAction exist from Step 11
 * - Requires Supabase real-time enabled for the chat_messages table
 * - Scrolls to the latest message on update using a ref
 * - Handles edge cases: no user, subscription errors, empty message list
 */

"use client"

import { useUser } from "@clerk/nextjs"
import { createClient } from "@supabase/supabase-js"
import { sendMessageAction } from "@/actions/db/chats-actions"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import { SelectChatMessage } from "@/db/schema/chat-messages-schema"
import { Send } from "lucide-react"
import { FormEvent, useEffect, useRef, useState } from "react"

// Initialize Supabase client with environment variables
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
)

/**
 * ChatPage component renders the real-time chat interface.
 * @returns {JSX.Element} The chat UI with message list and input
 */
export default function ChatPage() {
  // Clerk user authentication
  const { user, isLoaded } = useUser()
  const [messages, setMessages] = useState<SelectChatMessage[]>([])
  const [newMessage, setNewMessage] = useState("")
  const messagesEndRef = useRef<HTMLDivElement>(null)

  // Scroll to the bottom of the message list when new messages arrive
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" })
  }

  // Fetch initial messages and set up real-time subscription
  useEffect(() => {
    if (!isLoaded || !user) return

    // Initial fetch of messages
    const fetchMessages = async () => {
      const { data, error } = await supabase
        .from("chat_messages")
        .select("*")
        .order("created_at", { ascending: true })

      if (error) {
        console.error("Error fetching messages:", error)
        return
      }
      setMessages(data || [])
    }

    fetchMessages()

    // Set up real-time subscription
    const channel = supabase
      .channel("chat_messages")
      .on(
        "postgres_changes",
        { event: "INSERT", schema: "public", table: "chat_messages" },
        payload => {
          setMessages(prev => [...prev, payload.new as SelectChatMessage])
        }
      )
      .subscribe()

    // Cleanup subscription on unmount
    return () => {
      supabase.removeChannel(channel)
    }
  }, [isLoaded, user])

  // Scroll to bottom when messages update
  useEffect(() => {
    scrollToBottom()
  }, [messages])

  // Handle sending a new message
  const handleSendMessage = async (e: FormEvent) => {
    e.preventDefault()
    if (!user || !newMessage.trim()) return

    const messageData = {
      userId: user.id,
      content: newMessage.trim()
    }

    const { isSuccess, message } = await sendMessageAction(newMessage.trim())
    if (isSuccess) {
      setNewMessage("") // Clear input on success
    } else {
      console.error("Failed to send message:", message)
    }
  }

  if (!isLoaded) {
    return (
      <div className="flex h-[calc(100vh-4rem)] items-center justify-center">
        <div className="text-muted-foreground">Loading chat...</div>
      </div>
    )
  }

  if (!user) {
    return (
      <div className="flex h-[calc(100vh-4rem)] items-center justify-center">
        <div className="text-muted-foreground">Please sign in to chat.</div>
      </div>
    )
  }

  return (
    <div className="container mx-auto flex h-[calc(100vh-4rem)] flex-col p-6">
      <h1 className="text-foreground mb-6 text-3xl font-bold">
        Community Chat
      </h1>

      {/* Message List */}
      <div className="bg-card flex-1 overflow-y-auto rounded-lg p-4 shadow-sm">
        {messages.length > 0 ? (
          messages.map(msg => (
            <div
              key={msg.id}
              className={`mb-4 flex ${
                msg.userId === user.id ? "justify-end" : "justify-start"
              }`}
            >
              <div
                className={`max-w-xs rounded-lg p-3 ${
                  msg.userId === user.id
                    ? "bg-primary text-primary-foreground"
                    : "bg-muted text-muted-foreground"
                }`}
              >
                <p>{msg.content}</p>
                <p className="mt-1 text-xs opacity-70">
                  {new Date(msg.createdAt).toLocaleTimeString()}
                </p>
              </div>
            </div>
          ))
        ) : (
          <div className="text-muted-foreground text-center">
            No messages yet. Start the conversation!
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      {/* Message Input */}
      <form onSubmit={handleSendMessage} className="mt-4 flex gap-2">
        <Input
          value={newMessage}
          onChange={e => setNewMessage(e.target.value)}
          placeholder="Type your message..."
          className="flex-1"
        />
        <Button type="submit" disabled={!newMessage.trim()}>
          <Send className="size-4" />
          <span className="sr-only">Send</span>
        </Button>
      </form>
    </div>
  )
}

================
File: app/community/tutors/page.tsx
================
/**
 * @description
 * This server-side page renders the tutor booking interface for the Learn Kannada app.
 * It allows premium users to book live tutor sessions by integrating with Stripe for payment.
 * Accessible only to authenticated users with a "pro" membership, it provides a clean UI
 * with a checkout button redirecting to Stripe.
 *
 * Key features:
 * - Authentication: Uses Clerk to ensure user is logged in
 * - Authorization: Checks for "pro" membership via profiles table
 * - Stripe Integration: Creates a checkout session via server action
 * - UI: Minimalistic design with Tailwind and Shadcn Button component
 *
 * @dependencies
 * - @clerk/nextjs/server: For authentication (auth helper)
 * - @/actions/stripe-actions: For creating Stripe checkout sessions (createTutorCheckoutSessionAction)
 * - @/actions/db/profiles-actions: For fetching user profile (getProfileByUserIdAction)
 * - @/components/ui/button: Shadcn Button for the checkout UI
 * - next/navigation: For redirecting unauthenticated users
 *
 * @notes
 * - This is a server component, marked with "use server" per frontend rules
 * - Assumes a Stripe product for tutor sessions is configured (user instruction provided)
 * - No client-side state management; all data fetching is server-side
 * - Error handling includes redirecting unauthenticated users and displaying membership errors
 * - Edge case: Non-premium users see a message instead of the checkout button
 */

"use server"

import { auth } from "@clerk/nextjs/server"
import { redirect } from "next/navigation"
import { Button } from "@/components/ui/button"
import {
  createTutorCheckoutSessionAction,
  CreateTutorCheckoutSessionParams
} from "@/actions/stripe-actions"
import { getProfileByUserIdAction } from "@/actions/db/profiles-actions"

// Define props interface for the page (Next.js dynamic route params)
interface TutorPageProps {
  params: Promise<{}> // No dynamic params needed, but included for type safety
}

/**
 * TutorPage renders the tutor booking interface for premium users.
 * @param {TutorPageProps} props - Next.js page props (unused params awaited)
 * @returns {JSX.Element} The tutor booking UI or an error message
 */
export default async function TutorPage({ params }: TutorPageProps) {
  // Await params for type safety (though unused here)
  await params

  // Authenticate user with Clerk
  const { userId } = await auth()

  // Redirect to sign-in if not authenticated
  if (!userId) {
    return redirect("/login")
  }

  // Fetch user profile to check membership status
  const profileResult = await getProfileByUserIdAction(userId)
  if (!profileResult.isSuccess || !profileResult.data) {
    return (
      <div className="bg-background flex min-h-screen items-center justify-center">
        <div className="text-foreground text-center">
          <h1 className="text-2xl font-semibold">Error</h1>
          <p className="mt-2">
            Unable to load your profile. Please try again later.
          </p>
        </div>
      </div>
    )
  }

  const profile = profileResult.data
  const isPremium = profile.membership === "pro"

  // Define checkout session parameters
  const checkoutParams: CreateTutorCheckoutSessionParams = {
    userId,
    successUrl: `${process.env.NEXT_PUBLIC_BASE_URL}/community/tutors/success`,
    cancelUrl: `${process.env.NEXT_PUBLIC_BASE_URL}/community/tutors`
  }

  // Function to handle checkout session creation
  async function getCheckoutUrl(): Promise<string | null> {
    const result = await createTutorCheckoutSessionAction(checkoutParams)
    if (result.isSuccess && result.data?.url) {
      return result.data.url
    }
    console.error("Failed to create checkout session:", result.message)
    return null
  }

  // Fetch checkout URL server-side
  const checkoutUrl = await getCheckoutUrl()

  return (
    <div className="bg-background flex min-h-screen flex-col items-center justify-center p-4">
      <div className="w-full max-w-md text-center">
        <h1 className="text-foreground mb-6 text-3xl font-bold">
          Book a Live Tutor Session
        </h1>
        <p className="text-muted-foreground mb-8">
          Connect with a Kannada tutor for personalized learning. Available
          exclusively for premium members.
        </p>

        {isPremium ? (
          checkoutUrl ? (
            <form action={checkoutUrl} method="POST">
              <Button
                type="submit"
                className="bg-primary text-primary-foreground hover:bg-primary/90 w-full"
              >
                Book Now with Stripe
              </Button>
            </form>
          ) : (
            <div className="text-destructive">
              Failed to load checkout. Please try again later.
            </div>
          )
        ) : (
          <div className="text-muted-foreground">
            <p>
              This feature is available only to premium members. Upgrade your
              plan to book a tutor session.
            </p>
            <Button
              variant="outline"
              className="mt-4"
              onClick={() => redirect("/pricing")}
            >
              Upgrade to Premium
            </Button>
          </div>
        )}
      </div>
    </div>
  )
}

================
File: app/components/learn/lesson-card.tsx
================
"use client"

import { SelectLesson } from "@/db/schema/lessons-schema"

interface LessonCardProps {
  lesson: SelectLesson
}

const LessonCard: React.FC<LessonCardProps> = ({ lesson }) => {
  return (
    <div className="rounded-lg bg-white p-4 shadow-md">
      <h2 className="text-xl font-bold">{lesson.title}</h2>
      <p className="capitalize text-gray-600">Level: {lesson.level}</p>
    </div>
  )
}

export default LessonCard

================
File: app/components/learn/LessonCardWrapper.tsx
================
"use client"

import { SelectLesson } from "@/db/schema/lessons-schema"

interface LessonCardProps {
  lesson: SelectLesson
}

const LessonCard: React.FC<LessonCardProps> = ({ lesson }) => {
  return (
    <div className="rounded-lg bg-white p-4 shadow-md">
      <h2 className="text-xl font-bold">{lesson.title}</h2>
      <p className="capitalize text-gray-600">Level: {lesson.level}</p>
    </div>
  )
}

export default LessonCard

================
File: app/components/learn/pronunciation-guide.tsx
================
/**
 * @description
 * This client-side component provides a pronunciation guide for the Learn Kannada app.
 * It allows users to practice speaking Kannada phrases by recording their speech using
 * the Web Speech API and displaying the transcribed result. Designed for use in lesson
 * pages to support interactive pronunciation learning.
 *
 * Key features:
 * - Phrase Display: Shows the Kannada phrase to practice
 * - Speech Recording: Uses Web Speech API to record and transcribe user speech
 * - Responsive UI: Clean, minimalistic design with Tailwind CSS and Shadcn components
 * - Error Handling: Handles unsupported browsers and recognition errors gracefully
 *
 * @dependencies
 * - @/components/ui/button: Shadcn Button for record/stop controls
 * - @/components/ui/textarea: Shadcn Textarea for displaying transcription
 * - lucide-react: Provides Mic and Send icons for UI
 * - react: Manages component state and effects
 * - @/types: Imports SpeechRecognition and SpeechRecognitionConstructor for type safety
 *
 * @notes
 * - Requires browser support for Web Speech API (SpeechRecognition); falls back gracefully if unsupported
 * - Language is set to "kn-IN" (Kannada) for accurate recognition
 * - Submission handler is passed as a prop to allow integration with server actions (e.g., assessPronunciationAction)
 * - Handles edge cases like empty transcripts or API errors with user feedback
 * - Uses native DOM SpeechRecognitionEvent with custom SpeechRecognition type for compatibility
 */

"use client"

import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"
import { Mic, Send } from "lucide-react"
import { useState } from "react"
import {
  SpeechRecognition,
  SpeechRecognitionEvent,
  SpeechRecognitionErrorEvent,
  SpeechRecognitionConstructor
} from "@/types/web-speech-types"

// Define props interface for type safety
interface PronunciationGuideProps {
  phrase: string // The Kannada phrase to practice
  onSubmit: (transcript: string) => Promise<void> // Handler to process the recorded speech
}

/**
 * PronunciationGuide component renders a UI for practicing pronunciation.
 * @param {PronunciationGuideProps} props - Phrase to practice and submission handler
 * @returns {JSX.Element} A UI with recording controls and transcript display
 */
export default function PronunciationGuide({
  phrase,
  onSubmit
}: PronunciationGuideProps) {
  const [isRecording, setIsRecording] = useState(false)
  const [transcript, setTranscript] = useState("")
  const [isSupported, setIsSupported] = useState(true)

  // Initialize SpeechRecognition with type safety
  const SpeechRecognitionType: SpeechRecognitionConstructor | undefined =
    window.SpeechRecognition || window.webkitSpeechRecognition
  const recognition: SpeechRecognition | null = SpeechRecognitionType
    ? new SpeechRecognitionType()
    : null

  // Configure recognition if available
  if (recognition) {
    recognition.continuous = false
    recognition.interimResults = false
    recognition.lang = "kn-IN" // Kannada language code

    // Handle transcription result
    recognition.onresult = (event: SpeechRecognitionEvent) => {
      const result = event.results[0][0].transcript
      setTranscript(result)
      setIsRecording(false)
    }

    // Handle recognition errors
    recognition.onerror = (event: SpeechRecognitionErrorEvent) => {
      console.error("Speech recognition error:", event.error)
      setTranscript(`Error: ${event.error}. Please try again.`)
      setIsRecording(false)
    }
  } else {
    setIsSupported(false)
  }

  // Handle recording toggle
  const toggleRecording = () => {
    if (!recognition) return

    if (isRecording) {
      recognition.stop()
    } else {
      setTranscript("") // Clear previous transcript
      recognition.start()
      setIsRecording(true)
    }
  }

  // Handle submission of the transcript
  const handleSubmit = async () => {
    if (transcript.trim()) {
      await onSubmit(transcript)
      setTranscript("") // Reset after successful submission
    }
  }

  return (
    <div className="w-full max-w-lg space-y-6 p-4">
      {/* Display the phrase to practice */}
      <div className="text-foreground text-lg font-medium">{phrase}</div>

      {/* Recording controls and transcript display */}
      {isSupported ? (
        <>
          <Button
            onClick={toggleRecording}
            disabled={!recognition}
            className="w-full"
            variant={isRecording ? "destructive" : "default"}
          >
            <Mic className="mr-2 size-4" />
            {isRecording ? "Stop Recording" : "Start Recording"}
          </Button>

          <Textarea
            value={transcript}
            onChange={e => setTranscript(e.target.value)} // Allow manual edits
            placeholder="Your speech will appear here..."
            className="h-32 resize-none"
            readOnly={isRecording} // Prevent edits during recording
          />

          <Button
            onClick={handleSubmit}
            disabled={!transcript.trim() || isRecording}
            className="w-full"
          >
            <Send className="mr-2 size-4" />
            Submit Speech
          </Button>
        </>
      ) : (
        <div className="text-muted-foreground text-center">
          Speech recognition is not supported in your browser. Please use a
          modern browser like Chrome or Firefox.
        </div>
      )}
    </div>
  )
}

================
File: app/dashboard/page.tsx
================
/**
 * @description
 * This server-side page renders the user dashboard for the Learn Kannada app.
 * It displays progress metrics including XP, streaks, and badges, supporting
 * the progress tracking and gamification feature to keep users motivated.
 *
 * Key features:
 * - Fetches progress data server-side using a server action
 * - Displays XP with a progress bar, streak count, and badge list
 * - Responsive UI: Uses Tailwind CSS and Shadcn components for a clean design
 * - Loading State: Implements Suspense for asynchronous data fetching
 *
 * @dependencies
 * - @/actions/db/progress-actions: Provides getProgressByUserIdAction
 * - @/components/ui/progress: Shadcn Progress bar for XP visualization
 * - @/db/schema/progress-schema: Imports SelectProgress for type safety
 * - @clerk/nextjs/server: Provides auth for user authentication
 * - lucide-react: Provides icons (Trophy, Flame)
 * - react: Provides Suspense for async rendering
 *
 * @notes
 * - Marked "use server" per server component rules
 * - Requires Clerk authentication; redirects unauthenticated users
 * - Assumes progress records exist; displays fallback if none found
 * - XP progress bar caps at 300 (Master badge threshold)
 */

"use server"

import { auth } from "@clerk/nextjs/server"
import { Suspense } from "react"
import { getProgressByUserIdAction } from "@/actions/db/progress-actions"
import { SelectProgress } from "@/db/schema/progress-schema"
import { Progress } from "@/components/ui/progress"
import { Trophy, Flame } from "lucide-react"

// Define props interface (though not directly used here due to server component)
interface DashboardPageProps {}

/**
 * DashboardPage component renders the user dashboard.
 * @returns {JSX.Element} The dashboard UI with progress metrics
 */
export default async function DashboardPage({}: DashboardPageProps) {
  const authResult = await auth()
  const { userId } = authResult

  if (!userId) {
    throw new Error("User not authenticated")
  }

  return (
    <Suspense fallback={<div>Loading dashboard...</div>}>
      <DashboardContentFetcher userId={userId} />
    </Suspense>
  )
}

/**
 * DashboardContentFetcher fetches progress data and renders the dashboard content.
 * @param {{ userId: string }} props - The authenticated user's ID
 * @returns {JSX.Element} The rendered dashboard content
 */
async function DashboardContentFetcher({ userId }: { userId: string }) {
  const { isSuccess, data, message } = await getProgressByUserIdAction(userId)

  if (!isSuccess || !data || data.length === 0) {
    return (
      <div className="text-muted-foreground p-4 text-center">
        {message ||
          "No progress data available yet. Start learning to track your progress!"}
      </div>
    )
  }

  // Use the latest progress record (assuming one per user for simplicity)
  const progress: SelectProgress = data[0]
  const xp = progress.xp || 0
  const streak = progress.streak || 0
  const badges = (progress.badges as string[]) || []

  // XP progress bar capped at 300 (Master badge threshold)
  const xpProgress = Math.min((xp / 300) * 100, 100)

  return (
    <div className="container mx-auto p-4">
      {/* Header */}
      <h1 className="mb-6 text-2xl font-bold">Your Learning Dashboard</h1>

      {/* XP Section */}
      <div className="mb-8">
        <h2 className="mb-2 text-lg font-semibold">
          Experience Points (XP): {xp}
        </h2>
        <Progress value={xpProgress} className="w-full" />
      </div>

      {/* Streak Section */}
      <div className="mb-8 flex items-center gap-2">
        <Flame className="size-6 text-orange-500" />
        <span className="text-lg font-semibold">
          Streak: {streak} day{streak !== 1 ? "s" : ""}
        </span>
      </div>

      {/* Badges Section */}
      <div>
        <h2 className="mb-2 text-lg font-semibold">Badges</h2>
        {badges.length > 0 ? (
          <div className="flex flex-wrap gap-4">
            {badges.map((badge, index) => (
              <div
                key={index}
                className="bg-muted text-foreground flex items-center gap-2 rounded-md p-2"
              >
                <Trophy className="size-5 text-yellow-500" />
                <span>{badge}</span>
              </div>
            ))}
          </div>
        ) : (
          <p className="text-muted-foreground">
            No badges earned yet. Keep learning!
          </p>
        )}
      </div>
    </div>
  )
}

================
File: app/db/schema/lessons-schema.ts
================
export interface SelectLesson {
  id: string
  level: "beginner" | "intermediate" | "advanced"
  title: string
  content: unknown // Adjust this type as necessary
  createdAt: Date
  updatedAt: Date
}

================
File: app/globals.css
================
/*
Global styles for the app.
*/

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 240 5.9% 10%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }

  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: app/layout.tsx
================
/*
The root server layout for the app.
*/

import {
  createProfileAction,
  getProfileByUserIdAction
} from "@/actions/db/profiles-actions"
import { Toaster } from "@/components/ui/toaster"
import { Providers } from "@/components/utilities/providers"
import { TailwindIndicator } from "@/components/utilities/tailwind-indicator"
import { cn } from "@/lib/utils"
import { ClerkProvider } from "@clerk/nextjs"
import { auth } from "@clerk/nextjs/server"
import type { Metadata } from "next"
import { Inter } from "next/font/google"
import "./globals.css"

const inter = Inter({ subsets: ["latin"] })

export const metadata: Metadata = {
  title: "Receipt AI",
  description: "A full-stack web app template."
}

export default async function RootLayout({
  children
}: {
  children: React.ReactNode
}) {
  const { userId } = await auth()

  if (userId) {
    const profileRes = await getProfileByUserIdAction(userId)
    if (!profileRes.isSuccess) {
      await createProfileAction({ userId })
    }
  }

  return (
    <ClerkProvider>
      <html lang="en" suppressHydrationWarning>
        <body
          className={cn(
            "bg-background mx-auto min-h-screen w-full scroll-smooth antialiased",
            inter.className
          )}
        >
          <Providers
            attribute="class"
            defaultTheme="light"
            enableSystem={false}
            disableTransitionOnChange
          >
            {children}

            <TailwindIndicator />

            <Toaster />
          </Providers>
        </body>
      </html>
    </ClerkProvider>
  )
}

================
File: app/learn/[level]/page.tsx
================
/**
 * @description
 * This server-side page renders a lesson for a specific level in the Learn Kannada app.
 * It fetches lesson data based on the dynamic [level] route parameter and displays the lesson
 * content, including a pronunciation guide for interactive learning.
 *
 * Key features:
 * - Dynamic Routing: Handles the [level] parameter as a Promise per Next.js 15
 * - Server-Side Data Fetching: Retrieves lesson data using a server action
 * - Pronunciation Practice: Integrates the PronunciationGuide client component
 * - Loading State: Uses Suspense for asynchronous data fetching
 *
 * @dependencies
 * - @/actions/db/lessons-actions: Provides getLessonAction for fetching lessons
 * - @/components/learn/pronunciation-guide: Client component for pronunciation practice
 * - react: Provides Suspense for async rendering
 * - @/db/schema/lessons-schema: Imports SelectLesson for type safety
 *
 * @notes
 * - Marked "use server" to adhere to server component rules
 * - Params are awaited as a Promise per Next.js 15 dynamic route behavior
 * - No direct client-side logic; data is passed to PronunciationGuide as props
 * - Placeholder onSubmit logs to console; will be replaced in Step 23 with assessPronunciationAction
 * - Handles edge case of lesson not found with a fallback message
 */

"use server"

import { Suspense } from "react"
import { getLessonAction } from "@/actions/db/lessons-actions"
import PronunciationGuide from "@/components/learn/pronunciation-guide"
import { SelectLesson } from "@/db/schema/lessons-schema"

/**
 * Props interface for the LessonPage component.
 * @interface LessonPageProps
 */
interface LessonPageProps {
  params: Promise<{ level: string }> // Dynamic route params as a Promise
}

/**
 * LessonPage component fetches and renders a lesson for a given level.
 * @param {LessonPageProps} props - The route parameters
 * @returns {JSX.Element} The lesson content with pronunciation guide
 */
export default async function LessonPage({ params }: LessonPageProps) {
  // Await the params Promise to get the level
  const { level } = await params

  return (
    <Suspense fallback={<div>Loading lesson...</div>}>
      <LessonContentFetcher level={level} />
    </Suspense>
  )
}

/**
 * LessonContentFetcher fetches lesson data and renders the content.
 * @param {{ level: string }} props - The level to fetch
 * @returns {JSX.Element} The rendered lesson content
 */
async function LessonContentFetcher({ level }: { level: string }) {
  // Define valid levels
  const validLevels = ["beginner", "intermediate", "advanced"] as const
  type LessonLevel = (typeof validLevels)[number]

  // Validate and assert the level type
  if (!validLevels.includes(level as LessonLevel)) {
    return (
      <div className="text-muted-foreground p-4 text-center">
        {"Invalid lesson level."}
      </div>
    )
  }

  // Fetch the lesson data using the server action
  const { isSuccess, data, message } = await getLessonAction(
    level as LessonLevel
  )

  // Handle case where lesson is not found or fetch fails
  if (!isSuccess || !data || data.length === 0) {
    return (
      <div className="text-muted-foreground p-4 text-center">
        {message || "Lesson not found for this level."}
      </div>
    )
  }

  // Assuming data is an array, select the first lesson
  const lesson = data[0] // Get the first lesson from the array

  // Type assertion to ensure content has a phrase property
  const lessonContent = lesson.content as { phrase: string; text: string }

  return (
    <div className="container mx-auto p-4">
      {/* Lesson Title */}
      <h1 className="mb-4 text-2xl font-bold">{lesson.title}</h1>

      {/* Lesson Content */}
      <div className="mb-6 text-lg">{lessonContent.text}</div>

      {/* Pronunciation Guide */}
      <PronunciationGuide
        phrase={lessonContent.phrase || "No phrase available"}
        onSubmit={async (transcript: string) => {
          // Placeholder: Log transcript; replace with assessPronunciationAction in Step 23
          console.log(`User said: ${transcript}`)
        }}
      />
    </div>
  )
}

================
File: app/learn/layout.tsx
================
/**
 * @description
 * This file defines the server-side layout component for the /learn routes in the Learn Kannada app.
 * It provides a structured layout with a sidebar for navigation and a main content area for rendering
 * nested pages. The layout supports the learning modules feature by offering navigation to different
 * lesson levels and placeholders for progress indicators.
 *
 * Key features:
 * - Sidebar Navigation: Links to beginner, intermediate, and advanced lesson levels
 * - Progress Indicators: Placeholder section for future integration with user progress data
 * - Responsive Design: Mobile-friendly layout using Tailwind CSS
 *
 * @dependencies
 * - lucide-react: Provides icons for navigation (BookOpen, GraduationCap)
 * - next/link: Enables client-side navigation for lesson level links
 * - react: Core React library for component structure
 *
 * @notes
 * - Marked as "use server" to comply with server component rules
 * - No async data fetching yet; progress indicators are placeholders until Step 15 integrates data
 * - Assumes lesson levels are "beginner", "intermediate", "advanced" per lessons-schema.ts
 * - Edge case: Mobile sidebar collapse not implemented yet; could be added in future iterations
 */

"use server"

import { BookOpen, GraduationCap } from "lucide-react"
import Link from "next/link"
import { ReactNode } from "react"

/**
 * Props interface for the LearnLayout component.
 * @interface LearnLayoutProps
 * @property {ReactNode} children - The content to render within the main area
 */
interface LearnLayoutProps {
  children: ReactNode
}

/**
 * The server-side layout component for /learn routes.
 * @param {LearnLayoutProps} props - Component props
 * @returns {JSX.Element} The rendered layout with sidebar and main content
 */
export default async function LearnLayout({ children }: LearnLayoutProps) {
  // Define navigation items for lesson levels
  const navItems = [
    { label: "Beginner", href: "/learn/beginner", icon: BookOpen },
    { label: "Intermediate", href: "/learn/intermediate", icon: BookOpen },
    { label: "Advanced", href: "/learn/advanced", icon: GraduationCap }
  ]

  return (
    <div className="bg-background flex min-h-screen flex-col md:flex-row">
      {/* Sidebar */}
      <aside className="bg-card w-full border-b p-4 md:w-64 md:border-b-0 md:border-r">
        <div className="mb-6">
          <h2 className="text-foreground text-xl font-semibold">
            Learn Kannada
          </h2>
          <p className="text-muted-foreground mt-1 text-sm">
            Explore lessons by level
          </p>
        </div>

        <nav>
          <ul className="space-y-2">
            {navItems.map(item => (
              <li key={item.href}>
                <Link
                  href={item.href}
                  className="text-foreground hover:bg-accent hover:text-accent-foreground flex items-center gap-2 rounded-md p-2"
                >
                  <item.icon className="size-5" />
                  <span>{item.label}</span>
                </Link>
              </li>
            ))}
          </ul>
        </nav>

        {/* Progress Indicators Placeholder */}
        <div className="mt-6">
          <h3 className="text-foreground text-lg font-medium">Your Progress</h3>
          <p className="text-muted-foreground mt-1 text-sm">
            Progress tracking coming soon...
          </p>
          {/* Future integration: Display XP, streak, badges here */}
        </div>
      </aside>

      {/* Main Content */}
      <main className="flex-1 p-6">{children}</main>
    </div>
  )
}

================
File: app/practice/[type]/page.tsx
================
/**
 * @description
 * This server-side page renders an interactive exercise for the Learn Kannada app based on the exercise type.
 * It fetches exercise data server-side and renders the appropriate client component (quiz, writing, or speaking)
 * with submission handling, supporting the interactive exercises feature.
 *
 * Key features:
 * - Dynamic Routing: Handles [type] parameter for quiz, writing, or speaking exercises
 * - Server-Side Data Fetching: Fetches exercises using a server action
 * - Exercise Rendering: Conditionally renders QuizExercise, WritingExercise, or SpeakingExercise
 * - Type Safety: Validates exercise content for SpeakingExercise compatibility
 *
 * @dependencies
 * - @/components/practice/quiz-exercise: Client component for quiz exercises
 * - @/components/practice/writing-exercise: Client component for writing exercises
 * - @/components/practice/speaking-exercise: Client component for speaking exercises
 * - @/actions/db/exercises-actions: Provides getExercisesByLessonIdAction and submitExerciseAction
 * - @/db/schema/exercises-schema: Imports SelectExercise for type safety
 * - next/navigation: Provides notFound for invalid types
 * - react: Provides Suspense for async rendering
 *
 * @notes
 * - Marked "use server" per server component rules
 * - Params are awaited as a Promise per Next.js 15 dynamic route behavior
 * - Validates content shape for SpeakingExercise to resolve type mismatch
 * - Handles edge cases like invalid type or missing exercise with 404
 */

"use server"

import QuizExercise from "@/components/practice/quiz-exercise"
import WritingExercise from "@/components/practice/writing-exercise"
import SpeakingExercise from "@/components/practice/speaking-exercise"
import {
  getExercisesByLessonIdAction,
  submitExerciseAction
} from "@/actions/db/exercises-actions"
import { SelectExercise } from "@/db/schema/exercises-schema"
import { notFound } from "next/navigation"
import { Suspense } from "react"

// Define props interface for the page
interface PracticePageProps {
  params: Promise<{ type: string }> // Dynamic route params as a Promise
}

/**
 * Type guard to check if content matches SpeakingExercise's expected shape.
 * @param content - The content to validate
 * @returns {boolean} True if content has a phrase string
 */
function isSpeakingExerciseContent(
  content: unknown
): content is { phrase: string } {
  return (
    typeof content === "object" &&
    content !== null &&
    "phrase" in content &&
    typeof (content as any).phrase === "string"
  )
}

/**
 * PracticePage component fetches and renders an exercise based on type.
 * @param {PracticePageProps} props - The route parameters
 * @returns {JSX.Element} The exercise component or 404
 */
export default async function PracticePage({ params }: PracticePageProps) {
  // Await the params Promise to get the type
  const { type } = await params

  // Validate the type parameter
  const validTypes = ["quiz", "writing", "speaking"] as const
  if (!validTypes.includes(type as any)) {
    return notFound()
  }

  return (
    <Suspense fallback={<div>Loading exercise...</div>}>
      <ExerciseContentFetcher type={type} />
    </Suspense>
  )
}

/**
 * ExerciseContentFetcher fetches exercise data and renders the content.
 * @param {{ type: string }} props - The exercise type to fetch
 * @returns {JSX.Element} The rendered exercise component
 */
async function ExerciseContentFetcher({ type }: { type: string }) {
  // Simulate fetching an exercise (replace with actual lessonId if needed)
  // Assuming a default lessonId for simplicity; adjust as per your app logic
  const { isSuccess, data, message } =
    await getExercisesByLessonIdAction("default-lesson-id")

  if (!isSuccess || !data || data.length === 0) {
    return (
      <div className="text-muted-foreground p-4 text-center">
        {message || "No exercises found."}
      </div>
    )
  }

  // Find the first exercise matching the type
  const exercise = data.find(ex => ex.type === type)

  if (!exercise) {
    return notFound()
  }

  // Handle submission (stub; replace with actual logic if needed)
  const handleSubmit = async (response: string) => {
    "use server"
    await submitExerciseAction(exercise.id, response)
  }

  // Render the appropriate exercise component based on type
  switch (exercise.type) {
    case "quiz":
      return <QuizExercise exercise={exercise} onSubmit={handleSubmit} />
    case "writing":
      return <WritingExercise exercise={exercise} onSubmit={handleSubmit} />
    case "speaking":
      // Validate and assert content for SpeakingExercise
      if (!isSpeakingExerciseContent(exercise.content)) {
        return (
          <div className="text-muted-foreground p-4 text-center">
            Invalid exercise content: missing phrase.
          </div>
        )
      }
      return (
        <SpeakingExercise
          exercise={{ id: exercise.id, content: exercise.content }}
          onSubmit={handleSubmit}
        />
      )
    default:
      // This should never happen due to prior validation, but TypeScript requires it
      return notFound()
  }
}

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/lib/hooks"
  }
}

================
File: components/dashboard/progress-chart.tsx
================
/**
 * @description
 * This client component renders an XP progress chart for the Learn Kannada app’s dashboard.
 * It visualizes user XP over time using Recharts, supporting the gamification feature.
 *
 * Key features:
 * - Displays a line chart of XP by date
 * - Responsive design with Tailwind CSS and Recharts’ ResponsiveContainer
 * - Receives chart data as props from a server component
 * - Clean, minimalistic UI per design requests
 *
 * @dependencies
 * - recharts: For LineChart and related components
 *
 * @notes
 * - Marked "use client" to comply with Next.js client-side rendering rules
 * - Assumes chartData is an array of { date: string, xp: number } objects
 * - No server-side logic; relies on props for data
 * - Handles empty data implicitly via Recharts (empty chart renders cleanly)
 */

"use client"

import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer
} from "recharts"

// Define props interface
interface ProgressChartProps {
  chartData: { date: string; xp: number }[]
}

/**
 * ProgressChart component renders the XP line chart.
 * @param {ProgressChartProps} props - Contains chart data
 * @returns {JSX.Element} The rendered chart
 */
export default function ProgressChart({ chartData }: ProgressChartProps) {
  return (
    <div className="h-64 w-full">
      <ResponsiveContainer width="100%" height="100%">
        <LineChart data={chartData}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="date" />
          <YAxis />
          <Tooltip />
          <Line
            type="monotone"
            dataKey="xp"
            stroke="#1E40AF" // Matches design system primary color
            strokeWidth={2}
          />
        </LineChart>
      </ResponsiveContainer>
    </div>
  )
}

================
File: components/landing/footer.tsx
================
/*
This server component provides the footer for the app.
*/

import { Github, Twitter } from "lucide-react"
import Link from "next/link"

export async function Footer() {
  return (
    <footer className="border-t">
      <div className="container mx-auto max-w-7xl px-4 py-12 md:px-6">
        <div className="grid grid-cols-1 gap-8 md:grid-cols-4">
          <div className="space-y-4">
            <h3 className="text-lg font-bold">Company</h3>
            <div className="flex flex-col gap-2">
              <Link
                href="/about"
                className="text-muted-foreground hover:text-foreground transition"
              >
                About
              </Link>
              <Link
                href="/blog"
                className="text-muted-foreground hover:text-foreground transition"
              >
                Blog
              </Link>
              <Link
                href="/careers"
                className="text-muted-foreground hover:text-foreground transition"
              >
                Careers
              </Link>
            </div>
          </div>

          <div className="space-y-4">
            <h3 className="text-lg font-bold">Product</h3>
            <div className="flex flex-col gap-2">
              <Link
                href="/features"
                className="text-muted-foreground hover:text-foreground transition"
              >
                Features
              </Link>
              <Link
                href="/pricing"
                className="text-muted-foreground hover:text-foreground transition"
              >
                Pricing
              </Link>
              <Link
                href="/docs"
                className="text-muted-foreground hover:text-foreground transition"
              >
                Documentation
              </Link>
            </div>
          </div>

          <div className="space-y-4">
            <h3 className="text-lg font-bold">Resources</h3>
            <div className="flex flex-col gap-2">
              <Link
                href="/support"
                className="text-muted-foreground hover:text-foreground transition"
              >
                Support
              </Link>
              <Link
                href="/terms"
                className="text-muted-foreground hover:text-foreground transition"
              >
                Terms
              </Link>
              <Link
                href="/privacy"
                className="text-muted-foreground hover:text-foreground transition"
              >
                Privacy
              </Link>
            </div>
          </div>

          <div className="space-y-4">
            <h3 className="text-lg font-bold">Social</h3>
            <div className="flex gap-4">
              <Link
                href="https://github.com"
                target="_blank"
                rel="noopener noreferrer"
              >
                <Github className="text-muted-foreground hover:text-foreground size-6 transition" />
              </Link>
              <Link
                href="https://twitter.com"
                target="_blank"
                rel="noopener noreferrer"
              >
                <Twitter className="text-muted-foreground hover:text-foreground size-6 transition" />
              </Link>
            </div>
          </div>
        </div>

        <div className="text-muted-foreground mt-12 pt-8 text-center">
          <p>
            &copy; {new Date().getFullYear()} Your Company. All rights reserved.
          </p>
        </div>
      </div>
    </footer>
  )
}

================
File: components/landing/header.tsx
================
/*
This client component provides the header for the app.
*/

"use client"

import { Button } from "@/components/ui/button"
import {
  SignedIn,
  SignedOut,
  SignInButton,
  SignUpButton,
  UserButton
} from "@clerk/nextjs"
import { motion } from "framer-motion"
import { Menu, Receipt, X } from "lucide-react"
import Link from "next/link"
import { useEffect, useState } from "react"

const navLinks = [
  { href: "/about", label: "About" },
  { href: "/features", label: "Features" },
  { href: "/pricing", label: "Pricing" },
  { href: "/contact", label: "Contact" }
]

const signedInLinks = [{ href: "/dashboard", label: "Dashboard" }]

export default function Header() {
  const [isMenuOpen, setIsMenuOpen] = useState(false)
  const [isScrolled, setIsScrolled] = useState(false)

  const toggleMenu = () => {
    setIsMenuOpen(!isMenuOpen)
  }

  useEffect(() => {
    const handleScroll = () => {
      setIsScrolled(window.scrollY > 0)
    }

    window.addEventListener("scroll", handleScroll)
    return () => window.removeEventListener("scroll", handleScroll)
  }, [])

  return (
    <motion.header
      initial={{ y: -20, opacity: 0 }}
      animate={{ y: 0, opacity: 1 }}
      className={`sticky top-0 z-50 transition-colors ${
        isScrolled
          ? "bg-background/80 shadow-sm backdrop-blur-sm"
          : "bg-background"
      }`}
    >
      <div className="container mx-auto flex max-w-7xl items-center justify-between p-4">
        <motion.div
          className="flex items-center space-x-2 hover:cursor-pointer hover:opacity-80"
          whileHover={{ scale: 1.05 }}
          whileTap={{ scale: 0.95 }}
        >
          <Receipt className="size-6" />
          <Link href="/" className="text-xl font-bold">
            Receipt AI
          </Link>
        </motion.div>

        <nav className="absolute left-1/2 hidden -translate-x-1/2 space-x-2 md:flex">
          {navLinks.map(link => (
            <motion.div
              key={link.href}
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
            >
              <Link
                href={link.href}
                className="text-muted-foreground hover:text-foreground rounded-full px-3 py-1 transition"
              >
                {link.label}
              </Link>
            </motion.div>
          ))}

          <SignedIn>
            {signedInLinks.map(link => (
              <motion.div
                key={link.href}
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
              >
                <Link
                  href={link.href}
                  className="text-muted-foreground hover:text-foreground rounded-full px-3 py-1 transition"
                >
                  {link.label}
                </Link>
              </motion.div>
            ))}
          </SignedIn>
        </nav>

        <div className="flex items-center space-x-4">
          <SignedOut>
            <SignInButton>
              <motion.div
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
              >
                <Button variant="ghost">Sign In</Button>
              </motion.div>
            </SignInButton>

            <SignUpButton>
              <motion.div
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
              >
                <Button>Get Started</Button>
              </motion.div>
            </SignUpButton>
          </SignedOut>

          <SignedIn>
            <UserButton />
          </SignedIn>

          <motion.div
            className="md:hidden"
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
          >
            <Button
              variant="ghost"
              size="icon"
              onClick={toggleMenu}
              aria-label="Toggle menu"
            >
              {isMenuOpen ? (
                <X className="size-6" />
              ) : (
                <Menu className="size-6" />
              )}
            </Button>
          </motion.div>
        </div>
      </div>

      {isMenuOpen && (
        <motion.nav
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -10 }}
          className="bg-primary-foreground text-primary p-4 md:hidden"
        >
          <ul className="space-y-2">
            <li>
              <Link
                href="/"
                className="block hover:underline"
                onClick={toggleMenu}
              >
                Home
              </Link>
            </li>
            {navLinks.map(link => (
              <li key={link.href}>
                <Link
                  href={link.href}
                  className="block hover:underline"
                  onClick={toggleMenu}
                >
                  {link.label}
                </Link>
              </li>
            ))}
            <SignedIn>
              {signedInLinks.map(link => (
                <li key={link.href}>
                  <Link
                    href={link.href}
                    className="block hover:underline"
                    onClick={toggleMenu}
                  >
                    {link.label}
                  </Link>
                </li>
              ))}
            </SignedIn>
          </ul>
        </motion.nav>
      )}
    </motion.header>
  )
}

================
File: components/landing/hero.tsx
================
/*
This client component provides the hero section for the landing page.
*/

"use client"

import { Button } from "@/components/ui/button"
import { cn } from "@/lib/utils"
import { motion } from "framer-motion"
import { ChevronRight, Rocket } from "lucide-react"
import Link from "next/link"
import AnimatedGradientText from "../magicui/animated-gradient-text"
import HeroVideoDialog from "../magicui/hero-video-dialog"

export const HeroSection = () => {
  return (
    <div className="flex flex-col items-center justify-center px-8 pt-32 text-center">
      <motion.div
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6, ease: "easeOut" }}
        className="flex items-center justify-center"
      >
        <Link href="https://github.com/mckaywrigley/o1-pro-template-system">
          <AnimatedGradientText>
            🚀 <hr className="mx-2 h-4 w-px shrink-0 bg-gray-300" />
            <span
              className={cn(
                `animate-gradient inline bg-gradient-to-r from-[#ffaa40] via-[#9c40ff] to-[#ffaa40] bg-[length:var(--bg-size)_100%] bg-clip-text text-transparent`
              )}
            >
              View the code on GitHub
            </span>
            <ChevronRight className="ml-1 size-3 transition-transform duration-300 ease-in-out group-hover:translate-x-0.5" />
          </AnimatedGradientText>
        </Link>
      </motion.div>

      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8, delay: 0.2, ease: "easeOut" }}
        className="mt-8 flex max-w-2xl flex-col items-center justify-center gap-6"
      >
        <motion.div
          initial={{ scale: 0.95, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          transition={{ duration: 0.6, delay: 0.4, ease: "easeOut" }}
          className="text-balance text-6xl font-bold"
        >
          Receipt AI
        </motion.div>

        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.6, delay: 0.6, ease: "easeOut" }}
          className="max-w-xl text-balance text-xl"
        >
          Transform receipts and invoices into organized data instantly with AI.
        </motion.div>

        <motion.div
          initial={{ opacity: 0, y: 10 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6, delay: 0.8, ease: "easeOut" }}
        >
          <Link href="https://github.com/mckaywrigley/o1-pro-template-system">
            <Button className="bg-blue-500 text-lg hover:bg-blue-600">
              <Rocket className="mr-2 size-5" />
              Get Started &rarr;
            </Button>
          </Link>
        </motion.div>
      </motion.div>

      <motion.div
        initial={{ opacity: 0, y: 30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 1, delay: 1, ease: "easeOut" }}
        className="mx-auto mt-20 flex w-full max-w-screen-lg items-center justify-center rounded-lg border shadow-lg"
      >
        <HeroVideoDialog
          animationStyle="top-in-bottom-out"
          videoSrc="https://www.youtube.com/embed/9yS0dR0kP-s"
          thumbnailSrc="hero.png"
          thumbnailAlt="Hero Video"
        />
      </motion.div>
    </div>
  )
}

================
File: components/learn/lesson-card.tsx
================
/**
 * @description
 * This server component renders a reusable card for displaying lesson previews in the Learn Kannada app.
 * It is designed to show a lesson's title, level (beginner, intermediate, advanced), and optionally the user's progress.
 * The component is used within server-side rendered pages like /learn/[level]/page.tsx to provide a consistent UI.
 *
 * Key features:
 * - Displays lesson title and level with clear typography
 * - Optionally shows progress as a percentage with a progress bar
 * - Uses Tailwind CSS and Shadcn Card for a clean, minimalistic, responsive design
 * - Accessible with ARIA labels for screen readers
 *
 * @dependencies
 * - @/components/ui/card: Shadcn Card component for consistent UI styling
 * - @/components/ui/progress: Shadcn Progress component for progress visualization
 * - @/db/schema/lessons-schema: Imports levelEnum for type safety on lesson levels
 *
 * @notes
 * - This is a server component, so it cannot include client-side interactivity (e.g., hooks)
 * - Progress is optional and only rendered if provided, defaulting to hidden
 * - Assumes parent component fetches and passes lesson data
 * - No direct data fetching here; relies on props for simplicity and reusability
 */

"use server"

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Progress } from "@/components/ui/progress"
import { levelEnum } from "@/db/schema/lessons-schema"

// Define props interface for type safety
interface LessonCardProps {
  title: string // Lesson title, required
  level: (typeof levelEnum.enumValues)[number] // Lesson level, constrained to enum values
  progress?: number // Optional progress percentage (0-100)
}

/**
 * LessonCard component renders a preview of a lesson.
 * @param {LessonCardProps} props - The lesson data to display
 * @returns {JSX.Element} A styled card with lesson details
 */
export async function LessonCard({ title, level, progress }: LessonCardProps) {
  // Validate progress value if provided
  const validProgress =
    progress !== undefined && progress >= 0 && progress <= 100
      ? progress
      : undefined

  return (
    <Card className="border-border w-full max-w-md border shadow-sm transition-shadow hover:shadow-md">
      <CardHeader>
        <CardTitle className="text-foreground text-xl font-semibold">
          {title}
        </CardTitle>
        {/* Capitalize level for display */}
        <div
          className="text-muted-foreground text-sm capitalize"
          aria-label={`Level: ${level}`}
        >
          {level}
        </div>
      </CardHeader>

      <CardContent>
        {validProgress !== undefined && (
          <div className="mt-4">
            {/* Progress label for accessibility */}
            <div
              className="text-muted-foreground mb-2 text-sm"
              aria-label={`Progress: ${validProgress}%`}
            >
              Progress: {validProgress}%
            </div>
            <Progress
              value={validProgress}
              className="w-full"
              aria-label={`Progress bar at ${validProgress}%`}
            />
          </div>
        )}
      </CardContent>
    </Card>
  )
}

================
File: components/learn/pronunciation-guide.tsx
================
/**
 * @description
 * This client-side component provides a pronunciation guide for the Learn Kannada app.
 * It allows users to practice speaking Kannada phrases by recording their speech using
 * the Web Speech API and displaying the transcribed result. Designed for use in lesson
 * pages to support interactive pronunciation learning.
 *
 * Key features:
 * - Phrase Display: Shows the Kannada phrase to practice
 * - Speech Recording: Uses Web Speech API to record and transcribe user speech
 * - Responsive UI: Clean, minimalistic design with Tailwind CSS and Shadcn components
 * - Error Handling: Handles unsupported browsers and recognition errors gracefully
 *
 * @dependencies
 * - @/components/ui/button: Shadcn Button for record/stop controls
 * - @/components/ui/textarea: Shadcn Textarea for displaying transcription
 * - lucide-react: Provides Mic and Send icons for UI
 * - react: Manages component state and effects
 * - @/types: Imports SpeechRecognitionConstructor for type safety
 *
 * @notes
 * - Requires browser support for Web Speech API; falls back gracefully if unsupported
 * - Language is set to "kn-IN" (Kannada) for accurate recognition
 * - Submission handler is passed as a prop to allow integration with server actions
 * - Uses native DOM types (SpeechRecognitionEvent, SpeechRecognitionErrorEvent) from lib.dom.d.ts
 */

"use client"

import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"
import { Mic, Send } from "lucide-react"
import { useState } from "react"
import { SpeechRecognitionConstructor } from "@/types"
import {
  SpeechRecognition,
  SpeechRecognitionEvent,
  SpeechRecognitionErrorEvent
} from "@/types/web-speech-types"

// Define props interface for type safety
interface PronunciationGuideProps {
  phrase: string // The Kannada phrase to practice
  onSubmit: (transcript: string) => Promise<void> // Handler to process the recorded speech
}

/**
 * PronunciationGuide component renders a UI for practicing pronunciation.
 * @param {PronunciationGuideProps} props - Phrase to practice and submission handler
 * @returns {JSX.Element} A UI with recording controls and transcript display
 */
export default function PronunciationGuide({
  phrase,
  onSubmit
}: PronunciationGuideProps) {
  const [isRecording, setIsRecording] = useState(false)
  const [transcript, setTranscript] = useState("")
  const [isSupported, setIsSupported] = useState(true)

  // Initialize SpeechRecognition with type safety
  const SpeechRecognition: SpeechRecognitionConstructor | undefined =
    window.SpeechRecognition || window.webkitSpeechRecognition
  const recognition = SpeechRecognition ? new SpeechRecognition() : null

  // Configure recognition if available
  if (recognition) {
    recognition.continuous = false
    recognition.interimResults = false
    recognition.lang = "kn-IN" // Kannada language code

    // Handle transcription result using native DOM type
    recognition.onresult = (event: SpeechRecognitionEvent) => {
      const result = event.results[0][0].transcript
      setTranscript(result)
      setIsRecording(false)
    }

    // Handle recognition errors using native DOM type
    recognition.onerror = (event: SpeechRecognitionErrorEvent) => {
      console.error("Speech recognition error:", event.error)
      setTranscript(`Error: ${event.error}. Please try again.`)
      setIsRecording(false)
    }
  } else {
    setIsSupported(false)
  }

  // Handle recording toggle
  const toggleRecording = () => {
    if (!recognition) return

    if (isRecording) {
      recognition.stop()
    } else {
      setTranscript("") // Clear previous transcript
      recognition.start()
      setIsRecording(true)
    }
  }

  // Handle submission of the transcript
  const handleSubmit = async () => {
    if (transcript.trim()) {
      await onSubmit(transcript)
      setTranscript("") // Reset after successful submission
    }
  }

  return (
    <div className="w-full max-w-lg space-y-6 p-4">
      {/* Display the phrase to practice */}
      <div className="text-foreground text-lg font-medium">{phrase}</div>

      {/* Recording controls and transcript display */}
      {isSupported ? (
        <>
          <Button
            onClick={toggleRecording}
            disabled={!recognition}
            className="w-full"
            variant={isRecording ? "destructive" : "default"}
          >
            <Mic className="mr-2 size-4" />
            {isRecording ? "Stop Recording" : "Start Recording"}
          </Button>

          <Textarea
            value={transcript}
            onChange={e => setTranscript(e.target.value)} // Allow manual edits
            placeholder="Your speech will appear here..."
            className="h-32 resize-none"
            readOnly={isRecording} // Prevent edits during recording
          />

          <Button
            onClick={handleSubmit}
            disabled={!transcript.trim() || isRecording}
            className="w-full"
          >
            <Send className="mr-2 size-4" />
            Submit Speech
          </Button>
        </>
      ) : (
        <div className="text-muted-foreground text-center">
          Speech recognition is not supported in your browser. Please use a
          modern browser like Chrome or Firefox.
        </div>
      )}
    </div>
  )
}

================
File: components/magicui/animated-gradient-text.tsx
================
/*
This client component provides an animated gradient text.
*/

import { ReactNode } from "react"

import { cn } from "@/lib/utils"

export default function AnimatedGradientText({
  children,
  className
}: {
  children: ReactNode
  className?: string
}) {
  return (
    <div
      className={cn(
        "group relative mx-auto flex max-w-fit flex-row items-center justify-center rounded-2xl bg-white/40 px-4 py-1.5 text-sm font-medium shadow-[inset_0_-8px_10px_#8fdfff1f] backdrop-blur-sm transition-shadow duration-500 ease-out [--bg-size:300%] hover:shadow-[inset_0_-5px_10px_#8fdfff3f] dark:bg-black/40",
        className
      )}
    >
      <div
        className={`animate-gradient absolute inset-0 block size-full bg-gradient-to-r from-[#ffaa40]/50 via-[#9c40ff]/50 to-[#ffaa40]/50 bg-[length:var(--bg-size)_100%] p-[1px] [border-radius:inherit] ![mask-composite:subtract] [mask:linear-gradient(#fff_0_0)_content-box,linear-gradient(#fff_0_0)]`}
      />

      {children}
    </div>
  )
}

================
File: components/magicui/hero-video-dialog.tsx
================
/*
This client component provides a video dialog for the hero section.
*/

"use client"

import { AnimatePresence, motion } from "framer-motion"
import { Play, XIcon } from "lucide-react"
import { useState } from "react"

import { cn } from "@/lib/utils"

type AnimationStyle =
  | "from-bottom"
  | "from-center"
  | "from-top"
  | "from-left"
  | "from-right"
  | "fade"
  | "top-in-bottom-out"
  | "left-in-right-out"

interface HeroVideoProps {
  animationStyle?: AnimationStyle
  videoSrc: string
  thumbnailSrc: string
  thumbnailAlt?: string
  className?: string
}

const animationVariants = {
  "from-bottom": {
    initial: { y: "100%", opacity: 0 },
    animate: { y: 0, opacity: 1 },
    exit: { y: "100%", opacity: 0 }
  },
  "from-center": {
    initial: { scale: 0.5, opacity: 0 },
    animate: { scale: 1, opacity: 1 },
    exit: { scale: 0.5, opacity: 0 }
  },
  "from-top": {
    initial: { y: "-100%", opacity: 0 },
    animate: { y: 0, opacity: 1 },
    exit: { y: "-100%", opacity: 0 }
  },
  "from-left": {
    initial: { x: "-100%", opacity: 0 },
    animate: { x: 0, opacity: 1 },
    exit: { x: "-100%", opacity: 0 }
  },
  "from-right": {
    initial: { x: "100%", opacity: 0 },
    animate: { x: 0, opacity: 1 },
    exit: { x: "100%", opacity: 0 }
  },
  fade: {
    initial: { opacity: 0 },
    animate: { opacity: 1 },
    exit: { opacity: 0 }
  },
  "top-in-bottom-out": {
    initial: { y: "-100%", opacity: 0 },
    animate: { y: 0, opacity: 1 },
    exit: { y: "100%", opacity: 0 }
  },
  "left-in-right-out": {
    initial: { x: "-100%", opacity: 0 },
    animate: { x: 0, opacity: 1 },
    exit: { x: "100%", opacity: 0 }
  }
}

export default function HeroVideoDialog({
  animationStyle = "from-center",
  videoSrc,
  thumbnailSrc,
  thumbnailAlt = "Video thumbnail",
  className
}: HeroVideoProps) {
  const [isVideoOpen, setIsVideoOpen] = useState(false)
  const selectedAnimation = animationVariants[animationStyle]

  return (
    <div className={cn("relative", className)}>
      <div
        className="group relative cursor-pointer"
        onClick={() => setIsVideoOpen(true)}
      >
        <img
          src={thumbnailSrc}
          alt={thumbnailAlt}
          width={1920}
          height={1080}
          className="w-full rounded-md border shadow-lg transition-all duration-200 ease-out group-hover:brightness-[0.8]"
        />
        <div className="absolute inset-0 flex scale-[0.9] items-center justify-center rounded-2xl transition-all duration-200 ease-out group-hover:scale-100">
          <div className="bg-primary/10 flex size-28 items-center justify-center rounded-full backdrop-blur-md">
            <div
              className={`from-primary/30 to-primary relative flex size-20 scale-100 items-center justify-center rounded-full bg-gradient-to-b shadow-md transition-all duration-200 ease-out group-hover:scale-[1.2]`}
            >
              <Play
                className="size-8 scale-100 fill-white text-white transition-transform duration-200 ease-out group-hover:scale-105"
                style={{
                  filter:
                    "drop-shadow(0 4px 3px rgb(0 0 0 / 0.07)) drop-shadow(0 2px 2px rgb(0 0 0 / 0.06))"
                }}
              />
            </div>
          </div>
        </div>
      </div>
      <AnimatePresence>
        {isVideoOpen && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            onClick={() => setIsVideoOpen(false)}
            exit={{ opacity: 0 }}
            className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-md"
          >
            <motion.div
              {...selectedAnimation}
              transition={{ type: "spring", damping: 30, stiffness: 300 }}
              className="relative mx-4 aspect-video w-full max-w-4xl md:mx-0"
            >
              <motion.button className="absolute -top-16 right-0 rounded-full bg-neutral-900/50 p-2 text-xl text-white ring-1 backdrop-blur-md dark:bg-neutral-100/50 dark:text-black">
                <XIcon className="size-5" />
              </motion.button>
              <div className="relative isolate z-[1] size-full overflow-hidden rounded-2xl border-2 border-white">
                <iframe
                  src={videoSrc}
                  className="size-full rounded-2xl"
                  allowFullScreen
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                ></iframe>
              </div>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  )
}

================
File: components/practice/chatbot.tsx
================
/**
 * @description
 * This client-side component renders a chatbot interface for the Learn Kannada app.
 * It allows users to practice conversational Kannada with AI-generated responses,
 * integrating with server actions for real-time feedback.
 *
 * Key features:
 * - Conversation history: Displays user and AI messages with timestamps
 * - Real-time input: Handles user messages with form submission
 * - AI integration: Uses getGrammarExplanationAction for responses (placeholder for future conversational action)
 * - Responsive design: Clean, minimalistic UI with Tailwind CSS and Shadcn components
 *
 * @dependencies
 * - @/actions/ai-actions: Imports getGrammarExplanationAction for AI responses
 * - @/components/ui/button: Shadcn Button for submission
 * - @/components/ui/input: Shadcn Input for message entry
 * - @/components/ui/scroll-area: Shadcn ScrollArea for conversation history
 * - lucide-react: Provides Send icon
 * - react: Manages state and effects
 *
 * @notes
 * - Runs as a client component ("use client") for interactive UI
 * - Currently uses getGrammarExplanationAction; a dedicated conversational action could be added later
 * - Messages are stored locally in state; persistence could be added with a backend table
 * - Assumes user input is in Kannada or Romanized Kannada; transliteration support pending
 * - Error handling displays messages in the UI for user feedback
 */

"use client"

import { getGrammarExplanationAction } from "@/actions/ai-actions"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Send } from "lucide-react"
import { FormEvent, useState } from "react"

/**
 * Interface for a chat message.
 */
interface ChatMessage {
  id: number // Unique identifier for each message
  sender: "user" | "ai" // Who sent the message
  content: string // Message text
  timestamp: string // ISO string of when the message was sent
}

/**
 * Chatbot component for conversational practice.
 * @returns {JSX.Element} The chatbot UI with input and message display
 */
export default function Chatbot() {
  // State for conversation history and current input
  const [messages, setMessages] = useState<ChatMessage[]>([])
  const [input, setInput] = useState("")
  const [isLoading, setIsLoading] = useState(false)

  // Handle form submission to send a message
  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault()
    if (!input.trim()) return // Prevent empty submissions

    const userMessage: ChatMessage = {
      id: Date.now(), // Simple ID based on timestamp
      sender: "user",
      content: input,
      timestamp: new Date().toISOString()
    }

    // Add user message to history
    setMessages(prev => [...prev, userMessage])
    setInput("") // Clear input field
    setIsLoading(true)

    try {
      // Call server action for AI response (using grammar explanation as a placeholder)
      const result = await getGrammarExplanationAction(input)
      const aiContent = result.isSuccess
        ? result.data
        : `Error: ${result.message}`

      const aiMessage: ChatMessage = {
        id: Date.now() + 1, // Ensure unique ID
        sender: "ai",
        content: aiContent,
        timestamp: new Date().toISOString()
      }

      // Add AI response to history
      setMessages(prev => [...prev, aiMessage])
    } catch (error) {
      // Handle unexpected errors (e.g., network issues)
      const errorMessage: ChatMessage = {
        id: Date.now() + 1,
        sender: "ai",
        content: "Sorry, something went wrong. Please try again.",
        timestamp: new Date().toISOString()
      }
      setMessages(prev => [...prev, errorMessage])
      console.error("Chatbot error:", error)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="bg-background mx-auto flex h-[500px] w-full max-w-md flex-col rounded-lg border p-4 shadow-md">
      {/* Chat history */}
      <ScrollArea className="mb-4 flex-1">
        {messages.length === 0 ? (
          <div className="text-muted-foreground text-center">
            Start a conversation to practice Kannada!
          </div>
        ) : (
          messages.map(message => (
            <div
              key={message.id}
              className={`mb-2 flex ${
                message.sender === "user" ? "justify-end" : "justify-start"
              }`}
            >
              <div
                className={`max-w-[70%] rounded-lg p-2 ${
                  message.sender === "user"
                    ? "bg-primary text-primary-foreground"
                    : "bg-muted text-foreground"
                }`}
              >
                <p>{message.content}</p>
                <p className="mt-1 text-xs opacity-70">
                  {new Date(message.timestamp).toLocaleTimeString()}
                </p>
              </div>
            </div>
          ))
        )}
      </ScrollArea>

      {/* Input form */}
      <form onSubmit={handleSubmit} className="flex gap-2">
        <Input
          value={input}
          onChange={e => setInput(e.target.value)}
          placeholder="Type your message in Kannada..."
          className="flex-1"
          disabled={isLoading}
        />

        <Button type="submit" disabled={isLoading || !input.trim()}>
          <Send className="size-4" />
          <span className="sr-only">Send message</span>
        </Button>
      </form>
    </div>
  )
}

================
File: components/practice/quiz-exercise.tsx
================
/**
 * @description
 * This client-side component renders a multiple-choice quiz exercise for the Learn Kannada app.
 * It displays a question with selectable options and handles submission to evaluate user answers.
 * Designed for use in /practice/[type]/page.tsx to support interactive learning.
 *
 * Key features:
 * - Displays a single question with multiple-choice options using radio buttons
 * - Manages form state and submission with React Hook Form
 * - Clean, responsive UI with Tailwind CSS and Shadcn components
 * - Submits selected answer to a provided handler function
 *
 * @dependencies
 * - @/components/ui/button: Shadcn Button for submission
 * - @/components/ui/form: Shadcn Form components for form structure
 * - @/components/ui/radio-group: Shadcn RadioGroup for options
 * - @/db/schema/exercises-schema: Imports SelectExercise for type safety
 * - react-hook-form: Manages form state and validation
 * - lucide-react: Provides icons (e.g., Check)
 *
 * @notes
 * - Requires a parent component to fetch exercise data and pass it as props
 * - Assumes content JSON has a question and options array
 * - Submission handler is expected to call a server action (e.g., submitExerciseAction)
 * - No direct server actions here; adheres to client component rules
 * - Handles edge case of missing/invalid content gracefully
 */

"use client"

import { Button } from "@/components/ui/button"
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage
} from "@/components/ui/form"
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group"
import { SelectExercise } from "@/db/schema/exercises-schema"
import { zodResolver } from "@hookform/resolvers/zod"
import { Check } from "lucide-react"
import { useForm } from "react-hook-form"
import * as z from "zod"

// Define form schema for validation
const quizFormSchema = z.object({
  answer: z.string().min(1, "Please select an answer")
})

// Infer form type from schema
type QuizFormValues = z.infer<typeof quizFormSchema>

// Define props interface
interface QuizExerciseProps {
  exercise: SelectExercise // Exercise data from database
  onSubmit: (answer: string) => Promise<void> // Handler to process submission
}

/**
 * QuizExercise component renders a multiple-choice quiz UI.
 * @param {QuizExerciseProps} props - Exercise data and submission handler
 * @returns {JSX.Element} A form with question and radio options
 */
export default function QuizExercise({
  exercise,
  onSubmit
}: QuizExerciseProps) {
  // Parse exercise content (assuming JSON structure: { question: string, options: string[] })
  const content = exercise.content as { question: string; options: string[] }
  const question = content?.question ?? "No question available"
  const options = content?.options ?? []

  // Initialize form with React Hook Form
  const form = useForm<QuizFormValues>({
    resolver: zodResolver(quizFormSchema),
    defaultValues: { answer: "" }
  })

  // Handle form submission
  const handleSubmit = async (data: QuizFormValues) => {
    await onSubmit(data.answer)
  }

  return (
    <div className="w-full max-w-lg p-4">
      <Form {...form}>
        <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-6">
          {/* Question display */}
          <div className="text-foreground text-lg font-medium">{question}</div>

          {/* Options */}
          <FormField
            control={form.control}
            name="answer"
            render={({ field }) => (
              <FormItem>
                <FormLabel className="sr-only">Select an answer</FormLabel>
                <FormControl>
                  <RadioGroup
                    onValueChange={field.onChange}
                    value={field.value}
                    className="space-y-2"
                  >
                    {options.length > 0 ? (
                      options.map((option, index) => (
                        <FormItem
                          key={index}
                          className="flex items-center space-x-3"
                        >
                          <FormControl>
                            <RadioGroupItem
                              value={option}
                              id={`option-${index}`}
                            />
                          </FormControl>
                          <FormLabel
                            htmlFor={`option-${index}`}
                            className="text-foreground"
                          >
                            {option}
                          </FormLabel>
                        </FormItem>
                      ))
                    ) : (
                      <div className="text-muted-foreground">
                        No options available
                      </div>
                    )}
                  </RadioGroup>
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          {/* Submit button */}
          <Button
            type="submit"
            disabled={form.formState.isSubmitting || !form.formState.isValid}
            className="w-full"
          >
            <Check className="mr-2 size-4" />
            Submit Answer
          </Button>
        </form>
      </Form>
    </div>
  )
}

================
File: components/practice/speaking-exercise.tsx
================
/**
 * @description
 * This client-side component renders a speaking exercise UI for the Learn Kannada app.
 * It allows users to record their speech, transcribe it using the Web Speech API,
 * and receive AI-generated pronunciation feedback. Designed for use in /practice/[type]/page.tsx.
 *
 * Key features:
 * - Speech Recording: Uses Web Speech API to capture and transcribe user speech
 * - Pronunciation Feedback: Submits transcript to AI server action for evaluation
 * - Responsive UI: Clean design with Tailwind CSS and Shadcn components
 * - Error Handling: Manages unsupported browsers and API errors
 *
 * @dependencies
 * - @/components/ui/button: Shadcn Button for recording and submission
 * - @/components/ui/textarea: Shadcn Textarea for transcript display
 * - @/actions/ai-actions: Imports assessPronunciationAction for feedback
 * - lucide-react: Provides Mic and Send icons
 * - react: Manages state and effects
 *
 * @notes
 * - Requires browser support for Web Speech API; falls back if unsupported
 * - Language set to "kn-IN" (Kannada) for accurate recognition
 * - No direct server actions are called here; submission is async via props
 * - Handles edge cases like empty transcripts or API failures with user feedback
 */

"use client"

import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"
import { assessPronunciationAction } from "@/actions/ai-actions"
import { Mic, Send } from "lucide-react"
import { useState } from "react"
import {
  SpeechRecognition,
  SpeechRecognitionEvent,
  SpeechRecognitionResultList,
  SpeechRecognitionErrorEvent
} from "@/types/web-speech-types"

// Extend the Window interface to include SpeechRecognition
interface Window {
  SpeechRecognition: typeof window.SpeechRecognition
  webkitSpeechRecognition: typeof window.webkitSpeechRecognition
}

// Define the type for SpeechRecognition constructor
type SpeechRecognitionConstructor = new () => SpeechRecognition

// Define props interface for type safety
interface SpeakingExerciseProps {
  exercise: {
    id: string
    content: { phrase: string } // Expected phrase from exercise content
  } // Exercise data from database
  onSubmit: (response: string) => Promise<void>
}

/**
 * SpeakingExercise component renders a UI for speaking practice with feedback.
 * @param {SpeakingExerciseProps} props - Exercise data including the expected phrase
 * @returns {JSX.Element} A UI with recording controls, transcript, and feedback
 */
export default function SpeakingExercise({ exercise }: SpeakingExerciseProps) {
  const [isRecording, setIsRecording] = useState(false)
  const [transcript, setTranscript] = useState("")
  const [feedback, setFeedback] = useState("")
  const [isSupported, setIsSupported] = useState(true)

  // Extract phrase from exercise content
  const phrase = exercise.content.phrase || "No phrase available"

  // Initialize SpeechRecognition
  const SpeechRecognition = (window.SpeechRecognition ||
    window.webkitSpeechRecognition) as SpeechRecognitionConstructor | undefined
  const recognition = SpeechRecognition ? new SpeechRecognition() : null

  // Configure recognition if available
  if (recognition) {
    recognition.continuous = false
    recognition.interimResults = false
    recognition.lang = "kn-IN" // Kannada language code

    recognition.onresult = (event: SpeechRecognitionEvent) => {
      const result = event.results[0][0].transcript
      setTranscript(result)
      setIsRecording(false)
    }

    recognition.onerror = (event: SpeechRecognitionErrorEvent) => {
      console.error("Speech recognition error:", event.error)
      setIsRecording(false)
      setTranscript("Error recording speech. Please try again.")
    }
  } else {
    setIsSupported(false)
  }

  // Handle recording toggle
  const toggleRecording = () => {
    if (!recognition) return

    if (isRecording) {
      recognition.stop()
    } else {
      setTranscript("")
      setFeedback("") // Clear previous feedback
      recognition.start()
      setIsRecording(true)
    }
  }

  // Handle submission to get pronunciation feedback
  const handleSubmit = async () => {
    if (!transcript.trim()) {
      setFeedback("Please record something to submit.")
      return
    }

    const { isSuccess, data, message } = await assessPronunciationAction(
      transcript,
      phrase
    )

    if (isSuccess) {
      setFeedback(data)
    } else {
      setFeedback(message || "Failed to get feedback. Please try again.")
    }
  }

  return (
    <div className="w-full max-w-lg space-y-6 p-4">
      {/* Phrase display */}
      <div className="text-foreground text-lg font-medium">{phrase}</div>

      {/* Recording controls */}
      {isSupported ? (
        <>
          <Button
            onClick={toggleRecording}
            disabled={!recognition}
            className="w-full"
            variant={isRecording ? "destructive" : "default"}
          >
            <Mic className="mr-2 size-4" />
            {isRecording ? "Stop Recording" : "Start Recording"}
          </Button>

          {/* Transcript display */}
          <Textarea
            value={transcript}
            onChange={e => setTranscript(e.target.value)}
            placeholder="Your speech will appear here..."
            className="h-32 resize-none"
            readOnly={isRecording}
          />

          {/* Submit button */}
          <Button
            onClick={handleSubmit}
            disabled={!transcript.trim() || isRecording}
            className="w-full"
          >
            <Send className="mr-2 size-4" />
            Submit Speech
          </Button>

          {/* Feedback display */}
          {feedback && (
            <div className="text-foreground bg-muted rounded-md p-4">
              <strong>Feedback:</strong> {feedback}
            </div>
          )}
        </>
      ) : (
        <div className="text-muted-foreground">
          Speech recognition is not supported in your browser.
        </div>
      )}
    </div>
  )
}

================
File: components/practice/writing-exercise.tsx
================
/**
 * @description
 * This client-side component renders a writing exercise UI for the Learn Kannada app.
 * It provides a textarea for users to input text and submits it for evaluation.
 * Designed for use in /practice/[type]/page.tsx to support interactive learning.
 *
 * Key features:
 * - Displays a writing prompt with a textarea for user response
 * - Manages form state and submission with React Hook Form
 * - Clean, responsive UI with Tailwind CSS and Shadcn components
 * - Submits user text to a provided handler function
 *
 * @dependencies
 * - @/components/ui/button: Shadcn Button for submission
 * - @/components/ui/form: Shadcn Form components for form structure
 * - @/components/ui/textarea: Shadcn Textarea for user input
 * - @/db/schema/exercises-schema: Imports SelectExercise for type safety
 * - react-hook-form: Manages form state and validation
 * - lucide-react: Provides icons (e.g., Check)
 *
 * @notes
 * - Requires a parent component to fetch exercise data and pass it as props
 * - Assumes content JSON has a prompt string
 * - Submission handler is expected to call a server action (e.g., submitExerciseAction)
 * - No direct server actions here; adheres to client component rules
 * - Handles edge case of missing/invalid content
 */

"use client"

import { Button } from "@/components/ui/button"
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage
} from "@/components/ui/form"
import { Textarea } from "@/components/ui/textarea"
import { SelectExercise } from "@/db/schema/exercises-schema"
import { zodResolver } from "@hookform/resolvers/zod"
import { Check } from "lucide-react"
import { useForm } from "react-hook-form"
import * as z from "zod"

// Define form schema for validation
const writingFormSchema = z.object({
  response: z.string().min(1, "Please enter your response")
})

// Infer form type from schema
type WritingFormValues = z.infer<typeof writingFormSchema>

// Define props interface
interface WritingExerciseProps {
  exercise: SelectExercise // Exercise data from database
  onSubmit: (response: string) => Promise<void> // Handler to process submission
}

/**
 * WritingExercise component renders a writing exercise UI.
 * @param {WritingExerciseProps} props - Exercise data and submission handler
 * @returns {JSX.Element} A form with prompt and textarea
 */
export default function WritingExercise({
  exercise,
  onSubmit
}: WritingExerciseProps) {
  // Parse exercise content (assuming JSON structure: { prompt: string })
  const content = exercise.content as { prompt: string }
  const prompt = content?.prompt ?? "No prompt available"

  // Initialize form with React Hook Form
  const form = useForm<WritingFormValues>({
    resolver: zodResolver(writingFormSchema),
    defaultValues: { response: "" }
  })

  // Handle form submission
  const handleSubmit = async (data: WritingFormValues) => {
    await onSubmit(data.response)
  }

  return (
    <div className="w-full max-w-lg p-4">
      <Form {...form}>
        <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-6">
          {/* Prompt display */}
          <div className="text-foreground text-lg font-medium">{prompt}</div>

          {/* Textarea */}
          <FormField
            control={form.control}
            name="response"
            render={({ field }) => (
              <FormItem>
                <FormLabel className="sr-only">Your response</FormLabel>
                <FormControl>
                  <Textarea
                    placeholder="Type your response here..."
                    className="h-32 resize-none"
                    {...field}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          {/* Submit button */}
          <Button
            type="submit"
            disabled={form.formState.isSubmitting || !form.formState.isValid}
            className="w-full"
          >
            <Check className="mr-2 size-4" />
            Submit Response
          </Button>
        </form>
      </Form>
    </div>
  )
}

================
File: components/utilities/providers.tsx
================
/*
This client component provides the providers for the app.
*/

"use client"

import { TooltipProvider } from "@/components/ui/tooltip"
import {
  ThemeProvider as NextThemesProvider,
  ThemeProviderProps
} from "next-themes"

export const Providers = ({ children, ...props }: ThemeProviderProps) => {
  return (
    <NextThemesProvider {...props}>
      <TooltipProvider>{children}</TooltipProvider>
    </NextThemesProvider>
  )
}

================
File: components/utilities/tailwind-indicator.tsx
================
/*
This server component provides a tailwind indicator for the app in dev mode.
*/

"use server"

export async function TailwindIndicator() {
  // Don't show in production
  if (process.env.NODE_ENV === "production") return null

  return (
    <div className="fixed bottom-12 left-3 z-50 flex size-6 items-center justify-center rounded-full bg-gray-800 p-3 font-mono text-xs text-white">
      <div className="block sm:hidden">xs</div>
      <div className="hidden sm:block md:hidden">sm</div>
      <div className="hidden md:block lg:hidden">md</div>
      <div className="hidden lg:block xl:hidden">lg</div>
      <div className="hidden xl:block 2xl:hidden">xl</div>
      <div className="hidden 2xl:block">2xl</div>
    </div>
  )
}

================
File: components/utilities/theme-switcher.tsx
================
/*
This client component provides a theme switcher for the app.
*/

"use client"

import { cn } from "@/lib/utils"
import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"
import { HTMLAttributes, ReactNode } from "react"

interface ThemeSwitcherProps extends HTMLAttributes<HTMLDivElement> {
  children?: ReactNode
}

export const ThemeSwitcher = ({ children, ...props }: ThemeSwitcherProps) => {
  const { setTheme, theme } = useTheme()

  const handleChange = (theme: "dark" | "light") => {
    localStorage.setItem("theme", theme)
    setTheme(theme)
  }

  return (
    <div
      className={cn(
        "p-1 hover:cursor-pointer hover:opacity-50",
        props.className
      )}
      onClick={() => handleChange(theme === "light" ? "dark" : "light")}
    >
      {theme === "dark" ? (
        <Moon className="size-6" />
      ) : (
        <Sun className="size-6" />
      )}
    </div>
  )
}

================
File: db/db.ts
================
/*
 * Initializes the database connection and schema for the Learn Kannada app.
 * This file sets up Drizzle ORM with PostgreSQL via Supabase, defining the schema
 * structure that includes all tables used in the application.
 *
 * Key features:
 * - Connects to Supabase PostgreSQL using DATABASE_URL from .env.local
 * - Defines the schema object with all application tables
 *
 * @dependencies
 * - drizzle-orm/postgres-js: Drizzle ORM for PostgreSQL
 * - postgres: PostgreSQL client
 * - dotenv: Loads environment variables from .env.local
 * - @/db/schema: Schema definitions for all tables
 *
 * @notes
 * - Do not generate migrations here (per backend rules); migrations are handled externally
 */

import { config } from "dotenv"
import { drizzle } from "drizzle-orm/postgres-js"
import postgres from "postgres"

// Import existing schemas
import { profilesTable } from "@/db/schema/profiles-schema"
import { lessonsTable } from "@/db/schema/lessons-schema"
import { progressTable } from "@/db/schema/progress-schema"
import { exercisesTable } from "@/db/schema/exercises-schema" // Added to align with Step 6 completion
import { chatMessagesTable } from "@/db/schema/chat-messages-schema" // Updated to real import from type-only

// Load environment variables from .env.local
config({ path: ".env.local" })

// Define the schema object with all tables
const schema = {
  profiles: profilesTable,
  lessons: lessonsTable,
  progress: progressTable,
  exercises: exercisesTable, // Added exercises schema
  chatMessages: chatMessagesTable // Added chat messages schema
}

// Initialize PostgreSQL client with the connection string
const client = postgres(process.env.DATABASE_URL!)

// Export the Drizzle ORM instance with the schema
export const db = drizzle(client, { schema })

================
File: db/migrations/0000_freezing_peter_quill.sql
================
CREATE TYPE "public"."membership" AS ENUM('free', 'pro');--> statement-breakpoint
CREATE TABLE "profiles" (
	"user_id" text PRIMARY KEY NOT NULL,
	"membership" "membership" DEFAULT 'free' NOT NULL,
	"stripe_customer_id" text,
	"stripe_subscription_id" text,
	"created_at" timestamp DEFAULT now() NOT NULL,
	"updated_at" timestamp DEFAULT now() NOT NULL
);

================
File: db/migrations/meta/_journal.json
================
{
  "version": "7",
  "dialect": "postgresql",
  "entries": [
    {
      "idx": 0,
      "version": "7",
      "when": 1740416294089,
      "tag": "0000_freezing_peter_quill",
      "breakpoints": true
    }
  ]
}

================
File: db/migrations/meta/0000_snapshot.json
================
{
  "id": "9e6b58de-3c36-4d40-94ed-09966de4b473",
  "prevId": "00000000-0000-0000-0000-000000000000",
  "version": "7",
  "dialect": "postgresql",
  "tables": {
    "public.profiles": {
      "name": "profiles",
      "schema": "",
      "columns": {
        "user_id": {
          "name": "user_id",
          "type": "text",
          "primaryKey": true,
          "notNull": true
        },
        "membership": {
          "name": "membership",
          "type": "membership",
          "typeSchema": "public",
          "primaryKey": false,
          "notNull": true,
          "default": "'free'"
        },
        "stripe_customer_id": {
          "name": "stripe_customer_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "stripe_subscription_id": {
          "name": "stripe_subscription_id",
          "type": "text",
          "primaryKey": false,
          "notNull": false
        },
        "created_at": {
          "name": "created_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "timestamp",
          "primaryKey": false,
          "notNull": true,
          "default": "now()"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {},
      "policies": {},
      "checkConstraints": {},
      "isRLSEnabled": false
    }
  },
  "enums": {
    "public.membership": {
      "name": "membership",
      "schema": "public",
      "values": [
        "free",
        "pro"
      ]
    }
  },
  "schemas": {},
  "sequences": {},
  "roles": {},
  "policies": {},
  "views": {},
  "_meta": {
    "columns": {},
    "schemas": {},
    "tables": {}
  }
}

================
File: db/schema/chat-messages-schema.ts
================
/*
 * Defines the database schema for chat messages in the Learn Kannada app.
 * This file creates the chat_messages table to store peer-to-peer chat messages,
 * supporting the social feature for learners to practice together.
 *
 * Key features:
 * - Links to profiles via a foreign key (userId) with cascade delete
 * - Stores message content as text
 * - Includes a creation timestamp to track when messages were sent
 *
 * @dependencies
 * - drizzle-orm/pg-core: Provides PostgreSQL schema definition utilities
 * - @/db/schema/profiles-schema: Imports profilesTable for foreign key reference
 *
 * @notes
 * - No migrations are generated here; handled externally per backend rules
 * - Only createdAt is included per the technical specification; messages are immutable
 * - userId is required (notNull) to ensure messages are always tied to a user
 */

import { pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core"
import { profilesTable } from "@/db/schema/profiles-schema"

/**
 * Defines the chat messages table schema.
 * This table stores messages sent between users in the peer-to-peer chat system.
 */
export const chatMessagesTable = pgTable("chat_messages", {
  id: uuid("id").defaultRandom().primaryKey(), // Unique identifier for each message
  userId: text("user_id")
    .notNull()
    .references(() => profilesTable.userId, { onDelete: "cascade" }), // Foreign key to profiles, cascades on delete
  content: text("content").notNull(), // Message content, required
  createdAt: timestamp("created_at").defaultNow().notNull() // Creation timestamp
})

/**
 * Type definition for inserting a new chat message record.
 * Matches the schema structure for type-safe insertions.
 */
export type InsertChatMessage = typeof chatMessagesTable.$inferInsert

/**
 * Type definition for selecting a chat message record.
 * Matches the schema structure for type-safe queries.
 */
export type SelectChatMessage = typeof chatMessagesTable.$inferSelect

================
File: db/schema/exercises-schema.ts
================
/*
 * Defines the database schema for exercises in the Learn Kannada app.
 * This file creates the exercises table to store interactive exercise data,
 * such as quizzes, writing, and speaking exercises, linked to lessons.
 *
 * Key features:
 * - Links to lessons via a foreign key (lessonId) with cascade delete
 * - Uses an enum for exercise types (quiz, writing, speaking)
 * - Stores exercise content as JSON for structured data (e.g., questions, answers)
 * - Includes timestamps for creation and updates
 *
 * @dependencies
 * - drizzle-orm/pg-core: Provides PostgreSQL schema definition utilities
 * - @/db/schema/lessons-schema: Imports lessonsTable for foreign key reference
 *
 * @notes
 * - No migrations are generated here; handled externally per backend rules
 * - Content is JSON to allow flexible exercise structures
 * - lessonId is required (notNull) to ensure exercises are always tied to a lesson
 */

import {
  json,
  pgEnum,
  pgTable,
  text,
  timestamp,
  uuid
} from "drizzle-orm/pg-core"
import { lessonsTable } from "@/db/schema/lessons-schema"

/**
 * Defines the exercise type enum.
 * Represents the possible types of exercises supported by the app.
 */
export const exerciseTypeEnum = pgEnum("type", ["quiz", "writing", "speaking"])

/**
 * Defines the exercises table schema.
 * This table stores exercise data linked to a specific lesson.
 */
export const exercisesTable = pgTable("exercises", {
  id: uuid("id").defaultRandom().primaryKey(), // Unique identifier for each exercise
  lessonId: uuid("lesson_id")
    .notNull()
    .references(() => lessonsTable.id, { onDelete: "cascade" }), // Foreign key to lessons, cascades on delete
  type: exerciseTypeEnum("type").notNull(), // Type of exercise (quiz, writing, speaking)
  content: json("content").notNull(), // JSON content storing exercise details (e.g., questions, prompts)
  createdAt: timestamp("created_at").defaultNow().notNull(), // Creation timestamp
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .notNull()
    .$onUpdate(() => new Date()) // Update timestamp on modification
})

/**
 * Type definition for inserting a new exercise record.
 * Matches the schema structure for type-safe insertions.
 */
export type InsertExercise = typeof exercisesTable.$inferInsert

/**
 * Type definition for selecting an exercise record.
 * Matches the schema structure for type-safe queries.
 */
export type SelectExercise = typeof exercisesTable.$inferSelect

================
File: db/schema/index.ts
================
/*
 * Exports all database schemas for the Learn Kannada app.
 * This file centralizes schema exports for use in database operations.
 *
 * Key features:
 * - Exports all table definitions for Drizzle ORM integration
 *
 * @notes
 * - Follows project rule to export schemas from a single index file
 */

export * from "./profiles-schema"
export * from "./lessons-schema"
export * from "./progress-schema"
export * from "./exercises-schema" // Added to align with Step 6 completion
export * from "./chat-messages-schema" // Added export for chat messages schema

================
File: db/schema/lessons-schema.ts
================
/*
 * Defines the database schema for lessons in the Learn Kannada app.
 * This file creates the lessons table to store lesson data, including level,
 * title, and content, supporting the structured curriculum feature.
 *
 * Key features:
 * - Uses an enum for lesson levels (beginner, intermediate, advanced)
 * - Stores lesson content as JSON for structured data (grammar, vocab, sentences)
 * - Includes timestamps for creation and updates
 *
 * @dependencies
 * - drizzle-orm/pg-core: Provides PostgreSQL schema definition utilities
 *
 * @notes
 * - No migrations are generated here; handled externally per backend rules
 * - Content is JSON to allow flexible lesson structure
 */

import {
  json,
  pgEnum,
  pgTable,
  text,
  timestamp,
  uuid
} from "drizzle-orm/pg-core"

// Define the lesson level enum
export const levelEnum = pgEnum("level", [
  "beginner",
  "intermediate",
  "advanced"
])

// Define the lessons table
export const lessonsTable = pgTable("lessons", {
  id: uuid("id").defaultRandom().primaryKey(), // Unique identifier for each lesson
  level: levelEnum("level").notNull(), // Lesson difficulty level (beginner, intermediate, advanced)
  title: text("title").notNull(), // Human-readable title of the lesson
  content: json("content").notNull(), // JSON content storing lesson details (e.g., grammar, vocab)
  createdAt: timestamp("created_at").defaultNow().notNull(), // Creation timestamp
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .notNull()
    .$onUpdate(() => new Date()) // Update timestamp on modification
})

// Type definitions for insert and select operations
export type InsertLesson = typeof lessonsTable.$inferInsert
export type SelectLesson = typeof lessonsTable.$inferSelect

================
File: db/schema/profiles-schema.ts
================
/*
Defines the database schema for profiles.
*/

import { pgEnum, pgTable, text, timestamp } from "drizzle-orm/pg-core"

export const membershipEnum = pgEnum("membership", ["free", "pro"])

export const profilesTable = pgTable("profiles", {
  userId: text("user_id").primaryKey().notNull(),
  membership: membershipEnum("membership").notNull().default("free"),
  stripeCustomerId: text("stripe_customer_id"),
  stripeSubscriptionId: text("stripe_subscription_id"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .notNull()
    .$onUpdate(() => new Date())
})

export type InsertProfile = typeof profilesTable.$inferInsert
export type SelectProfile = typeof profilesTable.$inferSelect

================
File: db/schema/progress-schema.ts
================
/*
 * Defines the database schema for user progress in the Learn Kannada app.
 * This file creates the progress table to track user learning progress, including
 * XP points, streaks, and badges, with relationships to profiles and lessons.
 *
 * Key features:
 * - Links to profiles and lessons via foreign keys (userId and lessonId)
 * - Stores XP and streak as integers for gamification
 * - Uses JSON for badges to support flexible badge structures
 * - Includes timestamps for creation and updates
 *
 * @dependencies
 * - drizzle-orm/pg-core: Provides PostgreSQL schema definition utilities
 * - @/db/schema: Imports profilesTable and lessonsTable for foreign key references
 *
 * @notes
 * - No migrations are generated here; handled externally per backend rules
 * - lessonId is optional (nullable) to allow progress tracking without a specific lesson
 * - badges defaults to an empty array for new records
 */

import {
  integer,
  json,
  pgTable,
  text,
  timestamp,
  uuid
} from "drizzle-orm/pg-core"
import { profilesTable } from "@/db/schema/profiles-schema"
import { lessonsTable } from "@/db/schema/lessons-schema"

/**
 * Defines the progress table schema.
 * This table stores user progress data linked to their profile and optionally a lesson.
 */
export const progressTable = pgTable("progress", {
  id: uuid("id").defaultRandom().primaryKey(), // Unique identifier for each progress record
  userId: text("user_id")
    .notNull()
    .references(() => profilesTable.userId, { onDelete: "cascade" }), // Foreign key to profiles, cascades on delete
  lessonId: uuid("lesson_id").references(() => lessonsTable.id, {
    onDelete: "cascade"
  }), // Optional foreign key to lessons, cascades on delete
  xp: integer("xp").default(0).notNull(), // Experience points earned, defaults to 0
  streak: integer("streak").default(0).notNull(), // Current streak count, defaults to 0
  badges: json("badges").default([]).notNull(), // Array of badges earned, stored as JSON, defaults to empty array
  createdAt: timestamp("created_at").defaultNow().notNull(), // Creation timestamp
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .notNull()
    .$onUpdate(() => new Date()) // Update timestamp on modification
})

/**
 * Type definition for inserting a new progress record.
 * Matches the schema structure for type-safe insertions.
 */
export type InsertProgress = typeof progressTable.$inferInsert

/**
 * Type definition for selecting a progress record.
 * Matches the schema structure for type-safe queries.
 */
export type SelectProgress = typeof progressTable.$inferSelect

================
File: drizzle.config.ts
================
/*
Configures Drizzle for the app.
*/

import { config } from "dotenv"
import { defineConfig } from "drizzle-kit"

config({ path: ".env.local" })

export default defineConfig({
  schema: "./db/schema/index.ts",
  out: "./db/migrations",
  dialect: "postgresql",
  dbCredentials: { url: process.env.DATABASE_URL! }
})

================
File: lib/ai/openai.ts
================
/**
 * @description
 * This file configures the OpenAI client for the Learn Kannada app.
 * It initializes the OpenAI SDK with an API key from environment variables,
 * providing a reusable client instance for AI-driven features like grammar explanations.
 *
 * Key features:
 * - Secure initialization: Uses environment variable for API key
 * - Consistent versioning: Specifies a fixed API version
 * - App identification: Includes metadata for OpenAI tracking
 *
 * @dependencies
 * - openai: The OpenAI SDK for interacting with the API
 * - dotenv: Loads environment variables from .env.local (loaded globally in db.ts)
 *
 * @notes
 * - Requires OPENAI_API_KEY in .env.local (set up in Step 1)
 * - Throws an error if the API key is missing to prevent runtime failures
 * - Uses a specific API version (2024-02-15-preview) for stability; update as needed
 * - No direct API calls are made here; this is purely configuration
 */

import OpenAI from "openai"

// Initialize the OpenAI client with configuration
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!, // Expects key from .env.local; ! assumes it’s set per Step 1
  // Specify API version for consistency across calls
  // Using a preview version as of March 2025; adjust based on OpenAI’s latest stable version
  baseURL: "https://api.openai.com/v1",
  defaultHeaders: {
    "OpenAI-Beta": "v1" // Optional: Indicates beta features if needed
  }
})

// Validate the API key presence to fail fast if misconfigured
if (!process.env.OPENAI_API_KEY) {
  throw new Error(
    "OPENAI_API_KEY is not set in .env.local. Please add it as per Step 1 instructions."
  )
}

// Export the configured client for use in server actions
export { openai }

================
File: lib/hooks/use-copy-to-clipboard.tsx
================
/*
Hook for copying text to the clipboard.
*/

"use client"

import { useState } from "react"

export interface useCopyToClipboardProps {
  timeout?: number
}

export function useCopyToClipboard({
  timeout = 2000
}: useCopyToClipboardProps) {
  const [isCopied, setIsCopied] = useState<Boolean>(false)

  const copyToClipboard = (value: string) => {
    if (typeof window === "undefined" || !navigator.clipboard?.writeText) {
      return
    }

    if (!value) {
      return
    }

    navigator.clipboard.writeText(value).then(() => {
      setIsCopied(true)

      setTimeout(() => {
        setIsCopied(false)
      }, timeout)
    })
  }

  return { isCopied, copyToClipboard }
}

================
File: lib/hooks/use-mobile.tsx
================
/*
Hook to check if the user is on a mobile device.
*/

import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

================
File: lib/hooks/use-toast.ts
================
/*
Hook to display toast notifications.
*/

"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type { ToastActionElement, ToastProps } from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST"
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | { type: ActionType["ADD_TOAST"]; toast: ToasterToast }
  | { type: ActionType["UPDATE_TOAST"]; toast: Partial<ToasterToast> }
  | { type: ActionType["DISMISS_TOAST"]; toastId?: ToasterToast["id"] }
  | { type: ActionType["REMOVE_TOAST"]; toastId?: ToasterToast["id"] }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({ type: "REMOVE_TOAST", toastId: toastId })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT)
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map(t =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        )
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach(toast => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map(t =>
          t.id === toastId || toastId === undefined ? { ...t, open: false } : t
        )
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return { ...state, toasts: [] }
      }
      return {
        ...state,
        toasts: state.toasts.filter(t => t.id !== action.toastId)
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach(listener => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({ type: "UPDATE_TOAST", toast: { ...props, id } })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: open => {
        if (!open) dismiss()
      }
    }
  })

  return { id: id, dismiss, update }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId })
  }
}

export { toast, useToast }

================
File: lib/stripe.ts
================
/*
Contains the Stripe configuration for the app.
*/

import Stripe from "stripe"

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: "2025-02-24.acacia",
  appInfo: { name: "Receipt AI", version: "0.1.0" }
})

================
File: lib/utils.ts
================
/*
Contains the utility functions for the app.
*/

import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: license
================
MIT License

Copyright (c) 2025 Mckay Wrigley

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: middleware.ts
================
/*
Contains middleware for protecting routes, checking user authentication, and redirecting as needed.
*/

import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server"
import { NextResponse } from "next/server"

const isProtectedRoute = createRouteMatcher(["/todo(.*)", "/practice/(.*)", "/dashboard"])

export default clerkMiddleware(async (auth, req) => {
  const { userId, redirectToSignIn } = await auth()

  // If the user isn't signed in and the route is private, redirect to sign-in
  if (!userId && isProtectedRoute(req)) {
    return redirectToSignIn({ returnBackUrl: "/login" })
  }

  // If the user is logged in and the route is protected, let them view.
  return NextResponse.next()
})

export const config = {
  matcher: ["/((?!.*\\..*|_next).*)", "/", "/(api|trpc)(.*)"]
}

================
File: next.config.mjs
================
/*
Configures Next.js for the app.
*/

/** @type {import('next').NextConfig} */
const nextConfig = { images: { remotePatterns: [{ hostname: "localhost" }] } }

export default nextConfig

================
File: package.json
================
{
  "name": "learn-kannada",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "clean": "npm run lint:fix && npm run format:write",
    "type-check": "tsc --noEmit",
    "lint:fix": "next lint --fix",
    "format:write": "prettier --write \"{app,lib,db,components,context,types}/**/*.{ts,tsx}\" --cache",
    "format:check": "prettier --check \"{app,lib,db,components,context,types}/**/*.{ts,tsx}\" --cache",
    "analyze": "ANALYZE=true npm run build",
    "db:generate": "npx drizzle-kit generate",
    "db:migrate": "npx drizzle-kit migrate",
    "prepare": "husky install"
  },
  "dependencies": {
    "@clerk/backend": "^1.24.0",
    "@clerk/nextjs": "^6.11.2",
    "@clerk/themes": "^2.2.17",
    "@hookform/resolvers": "^4.0.0",
    "@radix-ui/react-accordion": "^1.2.3",
    "@radix-ui/react-alert-dialog": "^1.1.6",
    "@radix-ui/react-aspect-ratio": "^1.1.2",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-checkbox": "^1.1.4",
    "@radix-ui/react-collapsible": "^1.1.3",
    "@radix-ui/react-context-menu": "^2.2.6",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-hover-card": "^1.1.6",
    "@radix-ui/react-label": "^2.1.2",
    "@radix-ui/react-menubar": "^1.1.6",
    "@radix-ui/react-navigation-menu": "^1.2.5",
    "@radix-ui/react-popover": "^1.1.6",
    "@radix-ui/react-progress": "^1.1.2",
    "@radix-ui/react-radio-group": "^1.2.3",
    "@radix-ui/react-scroll-area": "^1.2.3",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slider": "^1.2.3",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-switch": "^1.1.3",
    "@radix-ui/react-tabs": "^1.1.3",
    "@radix-ui/react-toast": "^1.2.6",
    "@radix-ui/react-toggle": "^1.1.2",
    "@radix-ui/react-toggle-group": "^1.1.2",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@supabase/supabase-js": "^2.45.6",
    "@tailwindcss/postcss": "^4.0.6",
    "autoprefixer": "^10.4.20",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.4",
    "date-fns": "^3.6.0",
    "drizzle-orm": "^0.39.3",
    "embla-carousel-react": "^8.5.2",
    "framer-motion": "^12.4.2",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.475.0",
    "next": "^15.1.7",
    "next-themes": "^0.4.4",
    "openai": "^4.68.1",
    "postcss": "^8.5.2",
    "postgres": "^3.4.5",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.54.2",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.1",
    "sonner": "^1.7.4",
    "stripe": "^17.6.0",
    "tailwind-merge": "^3.0.1",
    "tailwindcss": "^3.4.17",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^1.1.2",
    "zod": "^3.24.2"
  },
  "devDependencies": {
    "@tailwindcss/typography": "^0.5.16",
    "@types/node": "^22",
    "@types/react": "^18.0",
    "@types/react-dom": "^18.0",
    "dotenv": "^16.4.7",
    "drizzle-kit": "^0.30.4",
    "eslint": "^9",
    "eslint-config-next": "15.1.7",
    "eslint-config-prettier": "^10.0.1",
    "eslint-plugin-tailwindcss": "^3.18.0",
    "husky": "^9.1.7",
    "prettier": "^3.5.0",
    "typescript": "^5"
  }
}

================
File: path/to/lesson-card
================
interface LessonCardProps {
    lesson: {
        level: "beginner" | "intermediate" | "advanced";
        id: string;
        title: string;
        content: unknown; // Adjust the type as necessary
        createdAt: Date;
        updatedAt: Date;
    };
}

const LessonCard: React.FC<LessonCardProps> = ({ lesson }) => {
    // Component implementation...
    return (
        <div>
            <h2>{lesson.title}</h2>
            {/* Render other lesson details as needed */}
        </div>
    );
}

export default LessonCard;

================
File: path/to/sendMessageAction
================
export async function sendMessageAction(messageData: { userId: string; content: string }): Promise<{ isSuccess: boolean; message?: string }> {
    // Example implementation (you should replace this with your actual logic)
    try {
        // Simulate sending a message (replace with actual sending logic)
        console.log("Sending message:", messageData);

        // Assuming the message is sent successfully
        return { isSuccess: true }; // Return success response
    } catch (error) {
        console.error("Error sending message:", error);
        return { isSuccess: false, message: "Failed to send message." }; // Return failure response
    }
}

================
File: postcss.config.mjs
================
/*
Configures PostCSS for the app.
*/

/** @type {import('postcss-load-config').Config} */
const config = { plugins: { tailwindcss: {} } }

export default config

================
File: prettier.config.cjs
================
/*
Configures Prettier for the app.
*/

/** @type {import('prettier').Config} */
module.exports = {
  endOfLine: "lf",
  semi: false,
  useTabs: false,
  singleQuote: false,
  arrowParens: "avoid",
  tabWidth: 2,
  trailingComma: "none",
  importOrder: [
    "^.+\\.scss$",
    "^.+\\.css$",
    "^(react/(.*)$)|^(react$)",
    "^(next/(.*)$)|^(next$)",
    "<THIRD_PARTY_MODULES>",
    "",
    "^types$",
    "^@/types/(.*)$",
    "^@/config/(.*)$",
    "^@/lib/(.*)$",
    "^@/hooks/(.*)$",
    "^@/components/ui/(.*)$",
    "^@/components/(.*)$",
    "^@/registry/(.*)$",
    "^@/styles/(.*)$",
    "^@/app/(.*)$",
    "",
    "^[./]"
  ],
  importOrderSeparation: false,
  importOrderSortSpecifiers: true,
  importOrderBuiltinModulesToTop: true,
  importOrderParserPlugins: ["typescript", "jsx", "decorators-legacy"],
  importOrderMergeDuplicateImports: true,
  importOrderCombineTypeAndValueImports: true
}

================
File: README.md
================
# Building Apps with the o1 Pro Template System

This is the repo for a free workshop on how to use [OpenAI's o1-pro](https://chatgpt.com/) to build full-stack web apps with a [starter template](https://github.com/mckaywrigley/mckays-app-template).

It is part 1 of a 2 part series. This is the beginner workshop. The advanced workshop will be released on February 24th.

## Workshop Video

You can find the video for this workshop on [X](https://x.com/mckaywrigley/status/1891544731496206365) and [YouTube](https://www.youtube.com/watch?v=Y4n_p9w8pGY).

This workshop is also available in course form on [Takeoff](https://www.jointakeoff.com/) - we will continue to add to it and keep it updated with the latest model releases over time.

Use code `O1PRO` for 25% off at checkout.

I get asked all the time for an example of content on Takeoff, so hopefully this workshop gives you a feel for our content and my teaching style.

## About Me

My name is [Mckay](https://www.mckaywrigley.com/).

I'm currently building [Takeoff](https://www.jointakeoff.com/) - the best place on the internet to learn how to build with AI.

Follow me on [X](https://x.com/mckaywrigley) and subscribe to my [YouTube](https://www.youtube.com/channel/UCXZFVVCFahewxr3est7aT7Q) for more free AI coding tutorials & guides.

## Tech Stack

- AI Model: [o1-pro](https://chatgpt.com/)
- IDE: [Cursor](https://www.cursor.com/)
- AI Tools: [RepoPrompt](https://repoprompt.com/), [V0](https://v0.dev/), [Perplexity](https://www.perplexity.com/)
- Frontend: [Next.js](https://nextjs.org/docs), [Tailwind](https://tailwindcss.com/docs/guides/nextjs), [Shadcn](https://ui.shadcn.com/docs/installation), [Framer Motion](https://www.framer.com/motion/introduction/)
- Backend: [PostgreSQL](https://www.postgresql.org/about/), [Supabase](https://supabase.com/), [Drizzle](https://orm.drizzle.team/docs/get-started-postgresql), [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)
- Auth: [Clerk](https://clerk.com/)
- Payments: [Stripe](https://stripe.com/)

**Note**: While I _highly_ recommend using o1-pro for this workflow, you can also use o3-mini, Claude 3.5 Sonnet, Gemini 2.0 Pro, and DeepSeek r1 for cheaper alternatives. However, you _will_ run into issues with those other models in this particular workflow, so I recommend using o1-pro for this workflow if possible.

## Prerequisites

You will need accounts for the following services.

They all have free plans that you can use to get started, with the exception of ChatGPT Pro (if you are using o1-pro).

- Create a [Cursor](https://www.cursor.com/) account
- Create a [GitHub](https://github.com/) account
- Create a [Supabase](https://supabase.com/) account
- Create a [Clerk](https://clerk.com/) account
- Create a [Stripe](https://stripe.com/) account
- Create a [Vercel](https://vercel.com/) account

You will likely not need paid plans unless you are building a business.

## Guide

### Clone the repo

1. Clone this repo:

```bash
git clone https://github.com/mckaywrigley/o1-pro-template-system o1-pro-project
```

2. Save the original remote as "upstream" before removing it:

```bash
git remote rename origin upstream
```

3. Create a new repository on GitHub

4. Add the new repository as "origin":

```bash
git remote add origin https://github.com/your-username/your-repo-name.git
```

5. Push the new repository:

```
git branch -M main
git push -u origin main
```

### Run the app

1. Install dependencies:

```bash
npm install
```

2. Run the app:

```bash
npm run dev
```

3.  View the app on http://localhost:3000

### Follow the workshop

View the full workshop on [X](https://x.com/mckaywrigley/status/1891544731496206365) and [YouTube](https://www.youtube.com/watch?v=Y4n_p9w8pGY).

Or sign up for [Takeoff](https://www.jointakeoff.com/) to get access to the full workshop in course form.

================
File: tailwind.config.ts
================
/*
Configures Tailwind CSS for the app.
*/

import type { Config } from "tailwindcss"

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}"
  ],
  prefix: "",
  theme: {
    container: { center: true, padding: "2rem", screens: { "2xl": "1400px" } },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))"
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))"
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))"
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))"
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))"
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))"
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))"
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))"
        }
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)"
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" }
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" }
        },
        gradient: { to: { backgroundPosition: "var(--bg-size) 0" } }
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        gradient: "gradient 8s linear infinite"
      }
    }
  },
  plugins: [
    require("tailwindcss-animate"),
    require("@tailwindcss/typography"),
    require("@tailwindcss/postcss")
  ]
} satisfies Config

export default config

================
File: tsconfig.json
================
/*
Configures the TypeScript compiler options for the app.
*/

{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [{ "name": "next" }],
    "paths": { "@/*": ["./*"] },
    "target": "ES2017"
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

================
File: types/index.ts
================
/**
 * @description
 * Exports all TypeScript types for the Learn Kannada app.
 * This file centralizes type exports for use across the application.
 *
 * Key features:
 * - Consolidates server action and Web Speech API types
 *
 * @notes
 * - Follows project rule to export all types from a single index file
 */

export * from "./server-action-types"
export * from "./web-speech-types" // Added to include SpeechRecognitionConstructor

================
File: types/server-action-types.ts
================
/*
Contains the general server action types.
*/

export type ActionState<T> =
  | { isSuccess: true; message: string; data: T }
  | { isSuccess: false; message: string; data?: never }

================
File: types/web-speech-types.ts
================
/**
 * @description
 * This file augments the global TypeScript types for the Web Speech API,
 * specifically adding SpeechRecognition and webkitSpeechRecognition to the Window interface.
 * It relies on native DOM types (SpeechRecognitionEvent, SpeechRecognitionResult, etc.)
 * from lib.dom.d.ts, ensuring compatibility with browser implementations.
 *
 * Key features:
 * - Extends Window with constructor types for SpeechRecognition
 *
 * @dependencies
 * - None (pure TypeScript augmentation leveraging lib.dom.d.ts)
 *
 * @notes
 * - Avoids redefining SpeechRecognitionEvent or related types to prevent conflicts
 * - Ensures type safety for both standard and webkit-prefixed implementations
 * - Wrapped in an ambient module to comply with TypeScript module scoping rules
 */

/**
 * Interface for the SpeechRecognition instance, matching native DOM type essentials.
 */
export interface SpeechRecognition {
  continuous: boolean
  interimResults: boolean
  lang: string
  start: () => void
  stop: () => void
  onresult: ((event: SpeechRecognitionEvent) => void) | null
  onerror: ((event: SpeechRecognitionErrorEvent) => void) | null
}

/**
 * Interface for SpeechRecognitionEvent, containing the recognition result.
 */
export interface SpeechRecognitionEvent {
  results: SpeechRecognitionResultList
}

/**
 * Interface for SpeechRecognitionErrorEvent, handling recognition errors.
 */
export interface SpeechRecognitionErrorEvent {
  error: string
}

/**
 * Constructor type for SpeechRecognition or webkitSpeechRecognition.
 * Compatible with the native SpeechRecognition interface from lib.dom.d.ts.
 */
export interface SpeechRecognitionConstructor {
  new (): SpeechRecognition
}

// Extend the global Window interface
declare global {
  interface Window {
    SpeechRecognition?: SpeechRecognitionConstructor
    webkitSpeechRecognition?: SpeechRecognitionConstructor
  }
}

/**
 * Interface for SpeechRecognitionResultList, holding the list of results.
 */
export interface SpeechRecognitionResultList {
  [index: number]: SpeechRecognitionResult
  length: number
  item(index: number): SpeechRecognitionResult
  [Symbol.iterator](): IterableIterator<SpeechRecognitionResult>
}

/**
 * Interface for SpeechRecognitionResult, representing a single recognition match.
 */
export interface SpeechRecognitionResult {
  [index: number]: SpeechRecognitionAlternative
  length: number
}

/**
 * Interface for SpeechRecognitionAlternative, containing the transcript.
 */
export interface SpeechRecognitionAlternative {
  transcript: string
}



================================================================
End of Codebase
================================================================
